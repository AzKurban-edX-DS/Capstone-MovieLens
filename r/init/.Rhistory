sum(ind)
models[ind]
ind
mean(y_hat == mnist_27$test$y)
fit
fits
str(fits[1])
fits['glm']
fits['glm']$glm$results$Accuracy
fits['glm']$result
fits['glm']$results
fits[1]
str(fits[1])
fits[1][1]
fits[2][1]
str(fits[1][1])
str(fits[1][1][1])
fits['knn']
fits['knn']['results']
fits['knn']$results
flist <- sapply(models, function(m){
fits[m]
})
flist
flist[1]
flist[1,]
flist[,1]
dim(flist)
flist[1]
flist[1]["Accuracy"]
flist[1]["results"]
str(flist[1])
names(fits['glm'])
fit['glm'][names(fits['glm'])]
fit['glm']['glm']
fits['glm']['glm']
fit <- fits['glm']
fit
unlist[fit]
class(fit)
unlist(fit)
fit_ul <- unlist(fit)
class(fit_ul)
fit_ul
str(fit_ul)
names(fit) <- NULL
fit
str(fit)
str(fit[1])
dim(fit)
fit[1][1]
fit[[1]]
str(fit[[1]])
fit[[1]]$results
fit <- fits['glm']
fit[['glm']]$results
fits['glm'][["glm"]]$results$Accuracy
accuracies <- sapply(models, function(m){
fits['glm'][["glm"]]$results$Accuracy
fits[m][[m]]$results$Accuracy
})
accuracies
str(accuracies)
as.vector(accuracies)
accuracies <- sapply(models, function(m){
fits['glm'][["glm"]]$results$Accuracy
acc <- fits[m][[m]]$results$Accuracy
mean(acc)
})
accuracies
accuracies <- sapply(models, function(m){
fits['glm'][["glm"]]$results#$Accuracy
#acc <- fits[m][[m]]$results$Accuracy
#mean(acc)
})
accuracies
accuracies["Accuracy",]
accuracies <- sapply(models, function(m){
#fits['glm'][["glm"]]$results#$Accuracy
acc <- fits[m][[m]]$results#$Accuracy
#mean(acc)
})
accuracies
accuracies["Accuracy",]
accuracies <- sapply(models, function(m){
#fits['glm'][["glm"]]$results#$Accuracy
fits[m][[m]]$results#$Accuracy
#mean(acc)
})
accuracies
accuracies["Accuracy",]
accuracies <- sapply(models, function(m){
#fits['glm'][["glm"]]$results#$Accuracy
acc <- fits[m][[m]]$results$Accuracy
mean(acc)
})
accuracies
accuracies["Accuracy",]
accuracies
mean(accuracies)
acc_hat <- sapply(fits, function(fit) min(fit$results$Accuracy))
acc_hat
mean(acc_hat)
acc_hat <- sapply(fits, function(fit) mean(fit$results$Accuracy))
acc_hat
mean(acc_hat)
mean(acc_hat)
head(pred)
ind <- acc_hat >= 0.8
ind
fits
best_fits <- fits[ind]
best_fits
best_fits <- fits[ind]
best_fits
best_pred <- sapply(best_fits, function(object)
predict(object, newdata = mnist_27$test))
dim(best_pred)
votes <- rowMeans(best_pred == "7")
y_hat <- ifelse(votes > 0.5, "7", "2")
mean(y_hat == mnist_27$test$y)
ind <- acc_hat >= 0.8
ind
best_fits <- fits[ind]
best_fits
best_pred <- sapply(best_fits, function(object)
predict(object, newdata = mnist_27$test))
dim(best_pred)
votes <- rowMeans(best_pred == "7")
y_hat <- ifelse(votes > 0.5, "7", "2")
mean(y_hat == mnist_27$test$y)
ind <- acc_hat >= 0.8
votes <- rowMeans(pred[,ind] == "7")
y_hat <- ifelse(votes>=0.5, 7, 2)
mean(y_hat == mnist_27$test$y)
library(tidyverse)
library(dslabs)
movielens |> as_tibble()
movielens |>
summarize(n_users = n_distinct(userId),
n_movies = n_distinct(movieId))
options(digits=3)
library(matrixStats)
library(tidyverse)
library(caret)
library(dslabs)
data(brca)
library(Matrix)
library(matrixStats)
x <- brca$x
y <- brca$y
str(brca)
dim(brca$x)
set.seed(1)
test_index <- createDataPartition(brca$y, times = 1, p = 0.2, list = FALSE)
test_x <- x_scaled[test_index,]
x_centered <- sweep(brca$x, 2, colMeans(brca$x))
x_scaled <- sweep(x_centered, 2, colSds(brca$x), FUN = "/")
sd(x_scaled[,1])
# The median value can be found using the following code:
median(x_scaled[,1])
pca <- prcomp(x_scaled)
str(pca)
dim(pca$x)
summary(pca)    # see PC1 Cumulative Proportion
data.frame(pca$x[,1:2], type = brca$y) %>%
ggplot(aes(PC1, PC2, color = type)) +
geom_point()
set.seed(1)
test_index <- createDataPartition(brca$y, times = 1, p = 0.2, list = FALSE)
test_x <- x_scaled[test_index,]
test_y <- brca$y[test_index]
train_x <- x_scaled[-test_index,]
train_y <- brca$y[-test_index]
options(digits=3)
library(matrixStats)
library(tidyverse)
library(caret)
library(dslabs)
data(brca)
library(Matrix)
library(matrixStats)
x <- brca$x
y <- brca$y
x_centered <- sweep(brca$x, 2, colMeans(brca$x))
x_scaled <- sweep(x_centered, 2, colSds(brca$x), FUN = "/")
sd(x_scaled[,1])
# The median value can be found using the following code:
median(x_scaled[,1])
pca <- prcomp(x_scaled)
summary(pca)    # see PC1 Cumulative Proportion
data.frame(pca$x[,1:2], type = brca$y) %>%
ggplot(aes(PC1, PC2, color = type)) +
geom_point()
data.frame(type = brca$y, pca$x[,1:10]) %>%
gather(key = "PC", value = "value", -type) %>%
ggplot(aes(PC, value, fill = type)) +
geom_boxplot()
set.seed(1)
test_index <- createDataPartition(brca$y, times = 1, p = 0.2, list = FALSE)
test_x <- x_scaled[test_index,]
test_y <- brca$y[test_index]
train_x <- x_scaled[-test_index,]
train_y <- brca$y[-test_index]
mean(train_y == "B")
mean(test_y == "B")
set.seed(1)
train_glm <- train(train_x, train_y, method = "glm")
glm_preds <- predict(train_glm, test_x)
mean(glm_preds == test_y)
set.seed(5)
train_loess <- train(train_x, train_y, method = "gamLoess")
loess_preds <- predict(train_loess, test_x)
mean(loess_preds == test_y)
set.seed(7)
tuning <- data.frame(k = seq(3, 21, 2))
train_knn <- train(train_x, train_y,
method = "knn",
tuneGrid = tuning)
train_knn$bestTune
knn_preds <- predict(train_knn, test_x)
mean(knn_preds == test_y)
library(randomForest)
set.seed(9)
train_rf <- train(train_x, train_y,
method = "rf",
data = train_set,
ntree = 100,
importance = TRUE,
tuneGrid = data.frame(mtry = c(3, 5, 7, 9))
)
train_rf
train_rf$bestTune
train_rf$finalModel
str(train_rf$finalModel)
rf_preds <- predict(train_rf, test_x)
mean(rf_preds == test_y)
str(glm_preds)
str(loess_preds)
str(knn_preds)
str(rf_preds)
?matrix
class(glm_preds)
preds <- c(glm_preds, loess_preds, knn_preds, rf_preds)
str(preds)
dim(preds)
ass_pred <- as.matrix(preds)
dim(ass_pred)
str(glm_preds)
class(glm_preds)
length(glm_preds)
ass_pred <- matrix(preds, nrow = 115, ncol = 4, dimnames = list(NULL, models))
length(models)
models <- c("glm", "gamLoess", "knn", "rf")
length(models)
ass_pred <- matrix(preds, nrow = 115, ncol = 4, dimnames = list(NULL, models))
dim(ass_pred)
head(ass_pred)
votes <- rowMeans(pred == 7)
head(votes)
votes <- rowMeans(pred == "M")
dim(votes)
head(votes)
votes <- rowMeans(ass_pred == "M")
str(votes)
head(votes)
length(votes)
y_hat <- ifelse(votes > 0.5, "M", "B")
y_hat
mean(y_hat == "M")
mean(y_hat == test_y)
str(brca$y)
head(brca$y)
length(brca$y)
x_centered <- sweep(brca$x, 2, colMeans(brca$x))
x_scaled <- sweep(x_centered, 2, colSds(brca$x), FUN = "/")
sd(x_scaled[,1])
# The median value can be found using the following code:
median(x_scaled[,1])
pca <- prcomp(x_scaled)
summary(pca)    # see PC1 Cumulative Proportion
data.frame(pca$x[,1:2], type = brca$y) %>%
ggplot(aes(PC1, PC2, color = type)) +
geom_point()
data.frame(type = brca$y, pca$x[,1:10]) %>%
gather(key = "PC", value = "value", -type) %>%
ggplot(aes(PC, value, fill = type)) +
geom_boxplot()
set.seed(1)
test_index <- createDataPartition(brca$y, times = 1, p = 0.2, list = FALSE)
test_x <- x_scaled[test_index,]
test_y <- brca$y[test_index]
train_x <- x_scaled[-test_index,]
train_y <- brca$y[-test_index]
mean(train_y == "B")
mean(test_y == "B")
set.seed(1)
train_glm <- train(train_x, train_y, method = "glm")
glm_preds <- predict(train_glm, test_x)
mean(glm_preds == test_y)
set.seed(5)
train_loess <- train(train_x, train_y, method = "gamLoess")
loess_preds <- predict(train_loess, test_x)
mean(loess_preds == test_y)
set.seed(7)
tuning <- data.frame(k = seq(3, 21, 2))
train_knn <- train(train_x, train_y,
method = "knn",
tuneGrid = tuning)
train_knn$bestTune
knn_preds <- predict(train_knn, test_x)
mean(knn_preds == test_y)
library(randomForest)
set.seed(9)
tuning <- data.frame(mtry = c(3, 5, 7, 9))
train_rf <- train(train_x, train_y,
method = "rf",
tuneGrid = tuning,
importance = TRUE)
train_rf$bestTune
rf_preds <- predict(train_rf, test_x)
mean(rf_preds == test_y)
varImp(train_rf)
models <- c("glm", "gamLoess", "knn", "rf")
length(models)
ass_pred <- matrix(preds, nrow = 115, ncol = 4, dimnames = list(NULL, models))
dim(ass_pred)
head(ass_pred)
votes <- rowMeans(ass_pred == "M")
str(votes)
head(votes)
length(votes)
y_hat <- ifelse(votes > 0.5, "M", "B")
y_hat
mean(y_hat == test_y)
acc <- colMeans(ass_pred ==  test_y)
acc
?rowMeans
votes
votes2 <- rowSums(ass_pred == "M")
votes2
mean(asm_preds == test_y)
asm_preds <- ifelse(votes2 > 2, "M", "B")
mean(asm_preds == test_y)
y_hat <- ifelse(votes >= 0.5, "M", "B")
y_hat
mean(y_hat == test_y)
asm_preds <- ifelse(votes2 >= 2, "M", "B")
mean(asm_preds == test_y)
ensemble <- cbind(glm = glm_preds == "B",
loess = loess_preds == "B",
rf = rf_preds == "B",
knn = knn_preds == "B")
dim(ensemble)
?cbind
head(ensemble)
ensemble_preds <- ifelse(rowMeans(ensemble) > 0.5, "B", "M")
mean(ensemble_preds == test_y)
asm_preds2 <- ifelse(votes2 > 2, "B", "M")
mean(asm_preds2 == test_y)
votes_B <- rowSums(ass_pred == "B")
asm_preds2 <- ifelse(votes_B > 2, "B", "M")
mean(asm_preds2 == test_y)
mvotes_B <- rowMeans(ass_pred == "B")
asm_preds_B <- ifelse(mvotes_B >= 0.5, "B", "M")
#y_hat
mean(asm_preds_B == test_y)
asm_preds_B <- ifelse(mvotes_B > 0.5, "B", "M")
#y_hat
mean(asm_preds_B == test_y)
acc
head(ass_pred)
acc <- colMeans(ass_pred == test_y)
acc
models <- c("Logistic regression", "Loess", "K nearest neighbors", "Random forest", "Ensemble")
accuracy <- c(mean(glm_preds == test_y),
mean(loess_preds == test_y),
mean(knn_preds == test_y),
mean(rf_preds == test_y),
mean(ensemble_preds == test_y))
data.frame(Model = models, Accuracy = accuracy)
library(tidyverse)
library(HistData)
galton_heights |>
mutate(z_father = round((father - mean(father)) / sd(father))) |>
filter(z_father %in% -2:2) |>
ggplot() +
stat_qq(aes(sample = son)) +
facet_wrap( ~ z_father)
?recosystem::Reco
str(edx)
# Create edx and final_holdout_test sets
# setwd(".../Capstone-MovieLens/r/init")
movielens_dataset_files <- "movielens-datasets.RData"
##########################################################
# Create edx and final_holdout_test sets
if(file.exists(movielens_dataset_files)){
load(movielens_dataset_files)
} else {
##########################################################
# Note: this process could take a couple of minutes
if(!require(tidyverse)) install.packages("tidyverse", repos = "http://cran.us.r-project.org")
if(!require(caret)) install.packages("caret", repos = "http://cran.us.r-project.org")
library(tidyverse)
library(caret)
options(timeout = 120)
# MovieLens 10M dataset:
# https://grouplens.org/datasets/movielens/10m/
# http://files.grouplens.org/datasets/movielens/ml-10m.zip
dl <- "ml-10M100K.zip"
# if(!file.exists(dl))
#   download.file("https://files.grouplens.org/datasets/movielens/ml-10m.zip", dl)
ratings_file <- "ml-10M100K/ratings.dat"
if(!file.exists(ratings_file))
unzip(dl, ratings_file)
movies_file <- "ml-10M100K/movies.dat"
if(!file.exists(movies_file))
unzip(dl, movies_file)
ratings <- as.data.frame(str_split(read_lines(ratings_file), fixed("::"), simplify = TRUE),
stringsAsFactors = FALSE)
colnames(ratings) <- c("userId", "movieId", "rating", "timestamp")
ratings <- ratings %>%
mutate(userId = as.integer(userId),
movieId = as.integer(movieId),
rating = as.numeric(rating),
timestamp = as.integer(timestamp))
movies <- as.data.frame(str_split(read_lines(movies_file), fixed("::"), simplify = TRUE),
stringsAsFactors = FALSE)
colnames(movies) <- c("movieId", "title", "genres")
movies <- movies %>%
mutate(movieId = as.integer(movieId))
movielens <- left_join(ratings, movies, by = "movieId")
# Final hold-out test set will be 10% of MovieLens data
set.seed(1, sample.kind="Rounding") # if using R 3.6 or later
# set.seed(1) # if using R 3.5 or earlier
test_index <- createDataPartition(y = movielens$rating, times = 1, p = 0.1, list = FALSE)
edx <- movielens[-test_index,]
temp <- movielens[test_index,]
#-----------------------------------------------------------------------
# Make sure userId and movieId in final hold-out test set are also in edx set
final_holdout_test <- temp %>%
semi_join(edx, by = "movieId") %>%
semi_join(edx, by = "userId")
# Add rows removed from final hold-out test set back into edx set
removed <- anti_join(temp, final_holdout_test)
edx <- rbind(edx, removed)
rm(dl, ratings, movies, test_index, temp, movielens, removed)
save(edx, final_holdout_test, file =  movielens_dataset_files)
}
setwd("C:/git/edx/ds/Capstone-MovieLens/r/init")
# Create edx and final_holdout_test sets
# setwd(".../Capstone-MovieLens/r/init")
movielens_dataset_files <- "movielens-datasets.RData"
##########################################################
# Create edx and final_holdout_test sets
if(file.exists(movielens_dataset_files)){
load(movielens_dataset_files)
} else {
##########################################################
# Note: this process could take a couple of minutes
if(!require(tidyverse)) install.packages("tidyverse", repos = "http://cran.us.r-project.org")
if(!require(caret)) install.packages("caret", repos = "http://cran.us.r-project.org")
library(tidyverse)
library(caret)
options(timeout = 120)
# MovieLens 10M dataset:
# https://grouplens.org/datasets/movielens/10m/
# http://files.grouplens.org/datasets/movielens/ml-10m.zip
dl <- "ml-10M100K.zip"
# if(!file.exists(dl))
#   download.file("https://files.grouplens.org/datasets/movielens/ml-10m.zip", dl)
ratings_file <- "ml-10M100K/ratings.dat"
if(!file.exists(ratings_file))
unzip(dl, ratings_file)
movies_file <- "ml-10M100K/movies.dat"
if(!file.exists(movies_file))
unzip(dl, movies_file)
ratings <- as.data.frame(str_split(read_lines(ratings_file), fixed("::"), simplify = TRUE),
stringsAsFactors = FALSE)
colnames(ratings) <- c("userId", "movieId", "rating", "timestamp")
ratings <- ratings %>%
mutate(userId = as.integer(userId),
movieId = as.integer(movieId),
rating = as.numeric(rating),
timestamp = as.integer(timestamp))
movies <- as.data.frame(str_split(read_lines(movies_file), fixed("::"), simplify = TRUE),
stringsAsFactors = FALSE)
colnames(movies) <- c("movieId", "title", "genres")
movies <- movies %>%
mutate(movieId = as.integer(movieId))
movielens <- left_join(ratings, movies, by = "movieId")
# Final hold-out test set will be 10% of MovieLens data
set.seed(1, sample.kind="Rounding") # if using R 3.6 or later
# set.seed(1) # if using R 3.5 or earlier
test_index <- createDataPartition(y = movielens$rating, times = 1, p = 0.1, list = FALSE)
edx <- movielens[-test_index,]
temp <- movielens[test_index,]
#-----------------------------------------------------------------------
# Make sure userId and movieId in final hold-out test set are also in edx set
final_holdout_test <- temp %>%
semi_join(edx, by = "movieId") %>%
semi_join(edx, by = "userId")
# Add rows removed from final hold-out test set back into edx set
removed <- anti_join(temp, final_holdout_test)
edx <- rbind(edx, removed)
rm(dl, ratings, movies, test_index, temp, movielens, removed)
save(edx, final_holdout_test, file =  movielens_dataset_files)
}
str(edx)
which git
?which
git --version
