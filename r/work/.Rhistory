mean(asm_preds == test_y)
ensemble <- cbind(glm = glm_preds == "B",
loess = loess_preds == "B",
rf = rf_preds == "B",
knn = knn_preds == "B")
dim(ensemble)
?cbind
head(ensemble)
ensemble_preds <- ifelse(rowMeans(ensemble) > 0.5, "B", "M")
mean(ensemble_preds == test_y)
asm_preds2 <- ifelse(votes2 > 2, "B", "M")
mean(asm_preds2 == test_y)
votes_B <- rowSums(ass_pred == "B")
asm_preds2 <- ifelse(votes_B > 2, "B", "M")
mean(asm_preds2 == test_y)
mvotes_B <- rowMeans(ass_pred == "B")
asm_preds_B <- ifelse(mvotes_B >= 0.5, "B", "M")
#y_hat
mean(asm_preds_B == test_y)
asm_preds_B <- ifelse(mvotes_B > 0.5, "B", "M")
#y_hat
mean(asm_preds_B == test_y)
acc
head(ass_pred)
acc <- colMeans(ass_pred == test_y)
acc
models <- c("Logistic regression", "Loess", "K nearest neighbors", "Random forest", "Ensemble")
accuracy <- c(mean(glm_preds == test_y),
mean(loess_preds == test_y),
mean(knn_preds == test_y),
mean(rf_preds == test_y),
mean(ensemble_preds == test_y))
data.frame(Model = models, Accuracy = accuracy)
setwd("C:/git/edx/ds/Capstone-MovieLens/r/init")
# Create edx and final_holdout_test sets
##########################################################
# Create edx and final_holdout_test sets
##########################################################
setwd("C:/git/edx/ds/Capstone-MovieLens/r/init")
# Note: this process could take a couple of minutes
if(!require(tidyverse)) install.packages("tidyverse", repos = "http://cran.us.r-project.org")
if(!require(caret)) install.packages("caret", repos = "http://cran.us.r-project.org")
library(tidyverse)
library(caret)
options(timeout = 120)
# MovieLens 10M dataset:
# https://grouplens.org/datasets/movielens/10m/
# http://files.grouplens.org/datasets/movielens/ml-10m.zip
dl <- "ml-10M100K.zip"
# if(!file.exists(dl))
#   download.file("https://files.grouplens.org/datasets/movielens/ml-10m.zip", dl)
ratings_file <- "ml-10M100K/ratings.dat"
if(!file.exists(ratings_file))
unzip(dl, ratings_file)
movies_file <- "ml-10M100K/movies.dat"
if(!file.exists(movies_file))
unzip(dl, movies_file)
ratings <- as.data.frame(str_split(read_lines(ratings_file), fixed("::"), simplify = TRUE),
stringsAsFactors = FALSE)
colnames(ratings) <- c("userId", "movieId", "rating", "timestamp")
ratings <- ratings %>%
mutate(userId = as.integer(userId),
movieId = as.integer(movieId),
rating = as.numeric(rating),
timestamp = as.integer(timestamp))
movies <- as.data.frame(str_split(read_lines(movies_file), fixed("::"), simplify = TRUE),
stringsAsFactors = FALSE)
colnames(movies) <- c("movieId", "title", "genres")
movies <- movies %>%
mutate(movieId = as.integer(movieId))
movielens <- left_join(ratings, movies, by = "movieId")
# Final hold-out test set will be 10% of MovieLens data
set.seed(1, sample.kind="Rounding") # if using R 3.6 or later
# set.seed(1) # if using R 3.5 or earlier
test_index <- createDataPartition(y = movielens$rating, times = 1, p = 0.1, list = FALSE)
edx <- movielens[-test_index,]
temp <- movielens[test_index,]
# Make sure userId and movieId in final hold-out test set are also in edx set
final_holdout_test <- temp %>%
semi_join(edx, by = "movieId") %>%
semi_join(edx, by = "userId")
# Add rows removed from final hold-out test set back into edx set
removed <- anti_join(temp, final_holdout_test)
edx <- rbind(edx, removed)
rm(dl, ratings, movies, test_index, temp, movielens, removed)
set.seed(2006)
probe_index <- createDataPartition(y = edx$rating, times = 1,
p = probe_set_ratio, list = FALSE)
library(caret)
library(lubridate)
library(dplyr)
# Prepare shared auxiliary functions -------------------------------------------
start_date <- function(){
print(date())
Sys.time()
}
end_date <- function(start){
print(date())
Sys.time() - start
}
RMSE <- function(true_ratings, predicted_ratings){
sqrt(mean((true_ratings - predicted_ratings)^2))
}
#-------------------------------------------------------------------------------
## The Netflix Prize Dataset
# https://www.asc.ohio-state.edu/statistics/statgen/joul_aut2009/BigChaos.pdf
# Initial Data -----------------------------------------
np_training_set_cnt <- 100480507
np_probe_set_cnt <- 1408395  # subset of `training_set`
probe_set_ratio <- np_probe_set_cnt/np_training_set_cnt
#> [1] 0.0140166
np_qualifying_set_cnt <- 2817131
quiz_set_ratio <- 0.5
test_set_ratio <- 1 - quiz_set_ratio
np_rmse_accepted_max <- 0.8563
#-------------------------------------------------------
#> The goal of the contest is to predict the qualifying set (size: 2817131 samples)
#> and achieve a RMSE score of at least 0.8563 on the quiz subset,
#> to get qualifed for the Grand Prize.
#####################################################
# Inspired by:
# HarvardX: PH125.8x
# Data Science: Machine Learning
## Section 6.2: Recommendation Systems
# Textbook:
### Section 33.7. Recommendation Systems
# https://rafalab.github.io/dsbook/large-datasets.html#recommendation-systems
# Split the `edx` dataset in `train_set` & `probe_set` ------------------------
#str(edx)
# 'data.frame':	9000055 obs. of  6 variables:
#   $ userId   : int  1 1 1 1 1 1 1 1 1 1 ...
# $ movieId  : int  122 185 292 316 329 355 356 362 364 370 ...
# $ rating   : num  5 5 5 5 5 5 5 5 5 5 ...
# $ timestamp: int  838985046 838983525 838983421 838983392 838983392 838984474 838983653 838984885 838983707 838984596 ...
# $ title    : chr  "Boomerang (1992)" "Net, The (1995)" "Outbreak (1995)" "Stargate (1994)" ...
# $ genres   : chr  "Comedy|Romance" "Action|Crime|Thriller" "Action|Drama|Sci-Fi|Thriller" "Action|Adventure|Sci-Fi" ...
#str(final_holdout_test)
# Prepare train & probe datasets ----------------------------------------------
set.seed(2006)
probe_index <- createDataPartition(y = edx$rating, times = 1,
p = probe_set_ratio, list = FALSE)
probe_set_tmp <- edx[probe_index,]
train_set <- edx[-probe_index,]
head(train_set)
#> Make sure userId and movieId in final hold-out test set
#> are also in `train_set` set
probe_set <- probe_set_tmp |>
semi_join(train_set, by = "movieId") |>
semi_join(train_set, by = "userId")
y_dat <- dplyr::select(train_set, movieId, userId, rating)
y_pw <- y_dat |>
pivot_wider(names_from = movieId, values_from = rating)
length(y_pw$userId)
#> [1] 69878
rnames <- y_pw$userId
y <- as.matrix(y_pw[,-1])
rownames(y) <- rnames
dim_y <- dim(y)
dim_y
# dim_y[1]*dim_y[2]
movie_map <- train_set |> dplyr::select(movieId, title) |>
distinct(movieId, .keep_all = TRUE)
# Calculate Naive RMSE -------------------------------------------------------
mu <- mean(train_set$rating)
mu
#> [1] 3.512465
naive_rmse <- RMSE(probe_set$rating, mu)
naive_rmse
#> [1] 1.061429
str(final_holdout_test)
head(final_holdout_test)
final_naive_rmse <- RMSE(final_holdout_test$rating, mu)
final_naive_rmse
hist(rowMeans(y, na.rm = TRUE), nclass = 30)
dim(y)
str(y_dat)
length(y_pw$userId)
str(y_pw)
class(y_pw)
dim(y_pw)
dim_y
head(y[1,])
head(y_pw[1,])
head(y_pw[,1])
str(y_pw[,1])
y_pw[1,1]
length(y_pw[,1])
str(y_pw[,1])
length(y_pw[1,])
dim(y)
str(edx)
setwd("C:/git/edx/ds/Capstone-MovieLens/r/work")
edx <- mutate(edx, userId = factor(userId), movieId = factor(movieId))
str(edx)
edx |> summarize(n_distinct(userId), n_distinct(movieId))
probe_set_ratio
setwd("C:/git/edx/ds/Capstone-MovieLens/r/init")
# Create edx and final_holdout_test sets
##########################################################
# Create edx and final_holdout_test sets
##########################################################
setwd("C:/git/edx/ds/Capstone-MovieLens/r/init")
# Note: this process could take a couple of minutes
if(!require(tidyverse)) install.packages("tidyverse", repos = "http://cran.us.r-project.org")
if(!require(caret)) install.packages("caret", repos = "http://cran.us.r-project.org")
library(tidyverse)
library(caret)
options(timeout = 120)
# MovieLens 10M dataset:
# https://grouplens.org/datasets/movielens/10m/
# http://files.grouplens.org/datasets/movielens/ml-10m.zip
dl <- "ml-10M100K.zip"
# if(!file.exists(dl))
#   download.file("https://files.grouplens.org/datasets/movielens/ml-10m.zip", dl)
ratings_file <- "ml-10M100K/ratings.dat"
if(!file.exists(ratings_file))
unzip(dl, ratings_file)
movies_file <- "ml-10M100K/movies.dat"
if(!file.exists(movies_file))
unzip(dl, movies_file)
ratings <- as.data.frame(str_split(read_lines(ratings_file), fixed("::"), simplify = TRUE),
stringsAsFactors = FALSE)
colnames(ratings) <- c("userId", "movieId", "rating", "timestamp")
ratings <- ratings %>%
mutate(userId = as.integer(userId),
movieId = as.integer(movieId),
rating = as.numeric(rating),
timestamp = as.integer(timestamp))
movies <- as.data.frame(str_split(read_lines(movies_file), fixed("::"), simplify = TRUE),
stringsAsFactors = FALSE)
colnames(movies) <- c("movieId", "title", "genres")
movies <- movies %>%
mutate(movieId = as.integer(movieId))
movielens <- left_join(ratings, movies, by = "movieId")
# Final hold-out test set will be 10% of MovieLens data
set.seed(1, sample.kind="Rounding") # if using R 3.6 or later
# set.seed(1) # if using R 3.5 or earlier
test_index <- createDataPartition(y = movielens$rating, times = 1, p = 0.1, list = FALSE)
edx <- movielens[-test_index,]
temp <- movielens[test_index,]
# Make sure userId and movieId in final hold-out test set are also in edx set
final_holdout_test <- temp %>%
semi_join(edx, by = "movieId") %>%
semi_join(edx, by = "userId")
# Add rows removed from final hold-out test set back into edx set
removed <- anti_join(temp, final_holdout_test)
edx <- rbind(edx, removed)
rm(dl, ratings, movies, test_index, temp, movielens, removed)
str(edx)
edx2 <- mutate(edx, userId = factor(userId), movieId = factor(movieId))
str(edx2)
edx_filtered <- edx2 |>
group_by(userId) |>
filter(n() >= 100) |>
ungroup()
str(edx_filtered)
edx_filtered |> summarize(n_distinct(userId), n_distinct(movieId))
edx2 |> summarize(n_distinct(userId), n_distinct(movieId))
edx100 <- edx2 |>
group_by(userId) |>
filter(n() >= 100) |>
ungroup()
#str(edx_filtered)
edx100 |> summarize(n_distinct(userId), n_distinct(movieId))
set.seed(2006)
indexes <- split(1:nrow(edx100), edx100$userId)
test_ind <- sapply(indexes, function(i) sample(i, ceiling(length(i)*.2))) |>
unlist() |>
sort()
test_set <- edx100[test_ind,]
train_set <- edx100[-test_ind,]
test_set <- test_set |> semi_join(train_set, by = "movieId")
head(train_set)
y <- select(train_set, movieId, userId, rating) |>
pivot_wider(names_from = movieId, values_from = rating) |>
column_to_rownames("userId") |>
as.matrix()
dim_y <- dim(y)
dim_y
movie_map <- train_set |> dplyr::select(movieId, title) |>
distinct(movieId, .keep_all = TRUE)
mu <- mean(train_set$rating)
mu
naive_rmse <- RMSE(probe_set$rating, mu)
naive_rmse
str(final_holdout_test)
head(final_holdout_test)
final_naive_rmse <- RMSE(final_holdout_test$rating, mu)
final_naive_rmse
train_set |>
group_by(userId) |>
summarize(user_ratings_avg = mean(rating)) |>
ggplot(aes(user_ratings_avg)) +
geom_histogram(bins = n_bins, color = "black")
n_bins <- 30
train_set |>
group_by(userId) |>
summarize(user_ratings_avg = mean(rating)) |>
ggplot(aes(user_ratings_avg)) +
geom_histogram(bins = n_bins, color = "black")
fit <- lm(rating ~ userId, data = train_set)
fit <- lm(rating ~ userId, data = train_set)
mu
a <- rowMeans(y - mu, na.rm = TRUE)
str(a)
?pmax
rmse
?rmse
clamp <- function(x, min = 0.5, max = 5) pmax(pmin(x, max), min)
# to keep predictions in that range and then compute the RMSE:
user_rmse <- function(test_set, a){
test_set |>
left_join(data.frame(userId = names(a), a = a), by = "userId") |>
mutate(resid = rating - clamp(mu + a)) |> pull(resid) |> rmse()
}
head(a)
user_effects_rmse <- function(test_set, a){
test_set |>
left_join(data.frame(userId = names(a), a = a), by = "userId") |>
mutate(resid = rating - clamp(mu + a)) |> pull(resid) |> rmse()
}
model_user_rmse <- user_effects_rmse(test_set, a)
rmse <- function(r) sqrt(mean(r^2))
model_user_rmse <- user_effects_rmse(test_set, a)
model_user_rmse
final_model_user_rmse <- user_effects_rmse(final_holdout_test, a)
str(x)
edx |> summarize(n_distinct(userId), n_distinct(movieId))
edx100 <- edx |>
group_by(userId) |>
filter(n() >= 100) |>
ungroup()
edx100 |> summarize(n_distinct(userId), n_distinct(movieId))
indexes <- split(1:nrow(edx100), edx100$userId)
test_ind <- sapply(indexes, function(i) sample(i, ceiling(length(i)*.2))) |>
unlist() |>
sort()
test_set <- edx100[test_ind,]
train_set <- edx100[-test_ind,]
#> To make sure we donâ€™t include movies in the training set that should not be
#> there, we remove entries using the semi_join function:
test_set <- test_set |> semi_join(train_set, by = "movieId")
head(train_set)
train_set <- mutate(train_set, userId = factor(userId), movieId = factor(movieId))
head(train_set)
y <- select(train_set, movieId, userId, rating) |>
pivot_wider(names_from = movieId, values_from = rating) |>
column_to_rownames("userId") |>
as.matrix()
dim_y <- dim(y)
dim_y
movie_map <- train_set |> dplyr::select(movieId, title) |>
distinct(movieId, .keep_all = TRUE)
user_effects_rmse <- function(test_set, a){
test_set |>
left_join(data.frame(userId = as.integer(names(a)), a = a), by = "userId") |>
mutate(resid = rating - clamp(mu + a)) |> pull(resid) |> rmse()
}
n_bins <- 30
train_set |>
group_by(userId) |>
summarize(user_ratings_avg = mean(rating)) |>
ggplot(aes(user_ratings_avg)) +
geom_histogram(bins = n_bins, color = "black")
a <- rowMeans(y - mu, na.rm = TRUE)
model_user_rmse <- user_effects_rmse(test_set, a)
model_user_rmse
final_model_user_rmse <- user_effects_rmse(final_holdout_test, a)
final_model_user_rmse
str(a)
mean(a)
mean(test_set$rating)
mean(final_holdout_test$rating)
mean(as.integer(names(a))
)
res <- test_set |>
left_join(data.frame(userId = as.integer(names(a)), a = a), by = "userId") |>
mutate(resid = rating - clamp(mu + a)) |> pull(resid)
mean(res)
res <- final_holdout_test |>
left_join(data.frame(userId = as.integer(names(a)), a = a), by = "userId") |>
mutate(resid = rating - clamp(mu + a)) |> pull(resid)
mean(res)
str(res)
head(test_set)
head(final_holdout_test)
str(test_set)
str(final_holdout_test)
str(edx)
str(edx100)
test_set <- test_set |> semi_join(train_set, by = "movieId") |>
as.data.frame()
test_set <- edx100[test_ind,]
str(test_set)
test_set <- edx100[test_ind,]
train_set <- edx100[-test_ind,]
test_set <- test_set |> semi_join(train_set, by = "movieId") |>
as.data.frame()
str(test_set)
str(a)
train_set <- mutate(train_set, userId = factor(userId), movieId = factor(movieId))
head(train_set)
y <- select(train_set, movieId, userId, rating) |>
pivot_wider(names_from = movieId, values_from = rating) |>
column_to_rownames("userId") |>
as.matrix()
dim_y <- dim(y)
dim_y
#> [1] 24115 10626
movie_map <- train_set |> dplyr::select(movieId, title) |>
distinct(movieId, .keep_all = TRUE)
mu <- mean(train_set$rating)
mu
#> [1] 3.471931
naive_rmse <- RMSE(probe_set$rating, mu)
naive_rmse
final_naive_rmse <- RMSE(final_holdout_test$rating, mu)
final_naive_rmse
hist(rowMeans(y, na.rm = TRUE), nclass = 30)
clamp <- function(x, min = 0.5, max = 5) pmax(pmin(x, max), min)
# to keep predictions in that range and then compute the RMSE:
user_effects_rmse <- function(test_set, a){
test_set |>
left_join(data.frame(userId = as.integer(names(a)), a = a), by = "userId") |>
mutate(resid = rating - clamp(mu + a)) |> pull(resid) |> rmse()
}
n_bins <- 30
train_set |>
group_by(userId) |>
summarize(user_ratings_avg = mean(rating)) |>
ggplot(aes(user_ratings_avg)) +
geom_histogram(bins = n_bins, color = "black")
a <- rowMeans(y - mu, na.rm = TRUE)
model_user_rmse <- user_effects_rmse(test_set, a)
model_user_rmse
final_model_user_rmse <- user_effects_rmse(final_holdout_test, a)
final_model_user_rmse
str(test_set)
str(final_holdout_test)
res <- final_holdout_test |>
left_join(data.frame(userId = as.integer(names(a)), a = a), by = "userId") |>
mutate(resid = rating - clamp(mu + a)) |> pull(resid)
mean(res)
res <- test_set |>
left_join(data.frame(userId = as.integer(names(a)), a = a), by = "userId") |>
mutate(resid = rating - clamp(mu + a)) |> pull(resid)
mean(res)
res <- final_holdout_test |>
left_join(data.frame(userId = as.integer(names(a)), a = a), by = "userId") |>
mutate(resid = rating - clamp(mu + a)) |> pull(resid)
mean(res)
length(res)
sum(is.na(res))
sum(is.na(test_set$rating))
sum(is.na(final_holdout_test$rating))
res <- final_holdout_test |>
left_join(data.frame(userId = as.integer(names(a)), a = a), by = "userId") |>
mutate(resid = rating - clamp(mu + a)) |> pull(resid)
mean(res)
res <- final_holdout_test |>
left_join(data.frame(userId = as.integer(names(a)), a = a), by = "userId") |>
mutate(resid = rating - clamp(mu + a)) |> pull(resid) |>
filter(!is.na(resid()))
res <- final_holdout_test |>
left_join(data.frame(userId = as.integer(names(a)), a = a), by = "userId") |>
mutate(resid = rating - clamp(mu + a)) |> pull(resid) |>
filter(!is.na(resid))
res <- final_holdout_test |>
left_join(data.frame(userId = as.integer(names(a)), a = a), by = "userId") |>
mutate(resid = rating - clamp(mu + a)) |>
filter(!is.na(resid)) |>
pull(resid)
mean(res)
user_effects_rmse <- function(test_set, a){
test_set |>
left_join(data.frame(userId = as.integer(names(a)), a = a), by = "userId") |>
mutate(resid = rating - clamp(mu + a)) |>
filter(!is.na(resid)) |>
pull(resid) |> rmse()
}
user_effects_rmse <- function(test_set, a){
test_set |>
left_join(data.frame(userId = as.integer(names(a)), a = a), by = "userId") |>
mutate(resid = rating - clamp(mu + a)) |>
filter(!is.na(resid)) |>
pull(resid) |> rmse()
}
final_model_user_rmse <- user_effects_rmse(final_holdout_test, a)
final_model_user_rmse
model_user_rmse <- user_effects_rmse(test_set, a)
model_user_rmse
model_user_rmse <- user_effects_rmse(test_set, a)
model_user_rmse
final_model_user_rmse <- user_effects_rmse(final_holdout_test, a)
final_model_user_rmse
setwd("C:/git/edx/ds/Capstone-MovieLens/r/work")
head(a)
user_and_movie_effects_rmse <- function(test_set, a, b){
test_set |>
left_join(data.frame(userId = as.integer(names(a)), a = a), by = "userId") |>
left_join(data.frame(movieId = as.integer(names(b)), b = b), by = "movieId") |>
mutate(resid = rating - clamp(mu + a + b)) |>
filter(!is.na(resid)) |>
pull(resid) |> rmse()
}
b <- colMeans(y - mu - a, na.rm = TRUE)
head(b)
str(b)
model_user_movie_rmse <- user_and_movie_effects_rmse(test_set, a, b)
model_user_movie_rmse
final_model_user_movie_rmse <- user_and_movie_effects_rmse(final_holdout_test, a, b)
final_model_user_movie_rmse
