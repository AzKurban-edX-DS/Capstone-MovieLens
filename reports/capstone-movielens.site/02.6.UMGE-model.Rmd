## User+Movie+Genre Effect (UMGE) Model
\

::: {.noteblock data-latex=""}
The complete source code of the _User+Movie+Genre Effect_ computation described in this section is available in the [User+Movie+Genre Effect (UMGE) Model](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L730) section of the [capstone-movielens.main.R](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L730) script on _GitHub_.
:::

As we can see from the `edx` dataset structure, the `Movielens` dataset also has a genres column. This column includes every genre that applies to the movie (some movies fall under several genres):
```{r}
str(edx)
```

### Movie Genres Effect Analysis
\

The plot below shows strong evidence of a genre effect (for illustrative purposes, the plot shows only categories with more than 40, 000 ratings).

```{r }
# Preparing data for plotting:
genre_ratins_grp <- edx |> 
  mutate(genre_categories = as.factor(genres)) |>
  group_by(genre_categories) |>
  summarize(n = n(), rating_avg = mean(rating), se = sd(rating)/sqrt(n())) |>
  filter(n > 40000) |> 
  mutate(genres = reorder(genre_categories, rating_avg)) |>
  select(genres, rating_avg, se, n)

# Creating plot:
genre_ratins_grp |> 
  ggplot(aes(x = genres, y = rating_avg, ymin = rating_avg - 2*se, ymax = rating_avg + 2*se)) + 
  geom_point() +
  geom_errorbar() + 
  ggtitle("Average rating per Genre") +
  ylab("Average rating") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

Below are worst and best ratings categories:
```{r, echo=FALSE}
sprintf("The worst ratings are for the genre category: %s",
        genre_ratins_grp$genres[which.min(genre_ratins_grp$genres)])

sprintf("The best ratings are for the genre category: %s",
        genre_ratins_grp$genres[which.max(genre_ratins_grp$genres)])
```

### Mathematical Description of the UMGE Model
\

If we define a _genre treatment effect_ $g_{i,j}$ for user's $i$ rating of movie $j$, we can use the following models to account for the `genre` effect:

\begin{equation}
Y_{i,j} = \mu + \alpha_i + \beta_j + g_{i,j} + \varepsilon_{i,j}
(\#eq:UMGE-model)
\end{equation}

where $g_{i,j}$ is an _aggregation function_ which is explained in detail in _Section 22.3: "Review of Aggregation Functions" of "Recommender Systems Handbook"_ (_Chapter 22: "Aggregation of Preferences in Recommender Systems"_, p. 712) book[@RRSK_RS_HB].

In the formula above $g_{i,j}$ denotes a _genre effect_ for user's $i$ rating of movie $j$, so that:

$$
g_{i,j} = \sum_{k=1}^K x_{i,j}^k \gamma_k
$$

with $x^k_{i,j} = 1$ if $g_{i,j}$ includes genre $k$, and $x^k_{i,j} = 0$ otherwise.

Therefore, for our current model, we can compute a predicted value 
$$
\hat{g}_{i,j} = g_{i,j} + \varepsilon_{i,j}
$$
as a residual: 


\begin{equation}
\hat{g}_{i,j} = Y_{i,j} - (\mu + \alpha_i + \beta_j)
(\#eq:genre-effect)
\end{equation}


### UMGE Model Building
\

::: {.noteblock data-latex=""}
The complete source code of builing and training the current model is available in the [UMGE Model Building](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L878) section of the [capstone-movielens.main.R](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L878) script on _GitHub_.
:::

Below is the [line of code](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L902) that trains our model with the use of *K-Fold Cross Validation* method, where the $K$ is the length of the [`edx_CV` Object] (described in detail in [Appendix B: Models Training Datasets]) to which the *K-Fold Cross-Validation* is applied (in *this Project*, we use $K = 5$):
```{r main-script@l902, fn.train_user_movie_genre_effect.cv,   eval=FALSE}
cv.UMG_effect <- train_user_movie_genre_effect.cv()
```

::: {.noteblock data-latex=""}
In the code snippet above we use the [train_user_movie_genre_effect.cv](#func.train_user_movie_genre_effect.cv) function described in section [UMGE Model: Utility Functions] of [Appendix A](#appndx_a).
:::

```{r}
str(cv.UMG_effect)
```

\newpage

The following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L925) plots a histogram that provides a visual representation of the variability of the *UMG Effect* across movies in the *data frame object* we have just obtained:
```{r main-script@l925}
par(cex = 0.7)
hist(cv.UMG_effect$g, 30, xlab = TeX(r'[$\hat{g}_{i,j}$]'),
     main = TeX(r'[Histogram of $\hat{g}_{i,j}$]'))
```

We can now construct predictors and calculate the *RMSE* score for the *UMGE Model* using the
following [line of code](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L932):
```{r main-script@l932, eval=FALSE}
cv.UMG_effect.RMSE <- calc_user_movie_genre_effect_RMSE.cv(cv.UMG_effect)
```
```{r}
cv.UMG_effect.RMSE
```

::: {.noteblock data-latex=""}
In the code snippet above, we use the [calc_user_movie_genre_effect_RMSE.cv](#func.calc_user_movie_genre_effect_RMSE.cv) function described in section [UMGE Model: Utility Functions] of [Appendix A](#appndx_a). 
:::

\newpage

Finally, we add the *RMSE* value obtained above to our *Result Table* and print the table using the following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L937):
```{r main-script@l937, eval=FALSE}
RMSEs.ResultTibble.UMGE <- RMSEs.ResultTibble.rglr.UME |> 
  RMSEs.AddRow("UMGE Model", 
               cv.UMG_effect.RMSE,
               comment = "User+Movie+Genre Effect (UMGE) Model")
```
```{r}
RMSE_kable(RMSEs.ResultTibble.UMGE)
```

::: {.noteblock data-latex=""}
In the code snippet above, we use the [RMSEs.AddRow](#func.RMSEs.AddRow) and [RMSE_kable](#func.RMSE_kable) functions described in section [Result RMSEs Tibble Functions] of [Appendix A](#appndx_a).
:::

Unfortunately, for some reason, we do not see any improvement here yet.

\newpage

### UMGE Model Regularization
\

::: {.noteblock data-latex=""}
The complete version of the source code provided in this section can be found in the [UMGE Model Regularization](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L948) section of the [capstone-movielens.main.R](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L948) script.
:::

We begin this section with the concept's mathematical description presented below in the subsection [UMGE Model Regularization: *Mathematical Description*].

Next, we will implement the *UMGE Model Regularization* in the following three steps:

  1. **Pre-configuration:** (Described in subsection [UMGE Model Regularization: *Pre-configuration*]) Preliminary determination of the optimal range of *regularization parameter* $\lambda$ values for the *K-Fold Cross-Validation* samples, where the $K$ is the length of the [`edx_CV` Object] (described in detail in [Appendix B: Models Training Datasets]) to which the *K-Fold Cross-Validation* is applied (in *this Project*, we use $K = 5$);
  
  2. **Fine-tuning:** (Described in the subsection [UMGE Model Regularization: *Fine-tuning*]) Determining the best value of $\lambda$ with the highest possible accuracy that minimizes the *RMSE* score for the model.

  3. **Retraining:** (Described in subsection [UMGE Model Regularization: *Retraining on the `edx` with the best* $\lambda$]) Retraining the model on the entire `edx` dataset with the best value of $\lambda$ determined in the previous step.


#### UMGE Model Regularization: *Mathematical Description*
\

We have already explained the idea of the *Linear Model Regularization* earlier in section [UME Model Regularization]. Let's extend the concept outlined there to our current model.

In this case, the formula \@ref(eq:ME-penalty) for adding a penalty takes the form:

\begin{equation}
\sum_{i,j} \left(y_{u,i} - \mu - \alpha_i - \beta_j - g_{i,j}\right)^2 + \lambda \sum_{i,j} g_{i,j}^2
(\#eq:GE-penalty)
\end{equation}

And the formula \@ref(eq:ME-regularized) for calculating the values of the _treatment effect_ that minimizes the equation will take the form:

\begin{equation}
\hat{g}_{i,j}(\lambda) = \frac{1}{\lambda + n_g} \sum_{r=1}^{n_{g}} \left(Y_{i,j} - \mu - \alpha_i - \beta_j\right)
(\#eq:GE-regularized)
\end{equation}

where $n_{g}$ is the number of ratings made for genre $g$. 

\newpage

#### UMGE Model Regularization: *Pre-configuration*
\

::: {.noteblock data-latex=""}
The complete version of the source code provided in this section can be found in the [UMGE Model Regularization: Pre-configuration](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L961) section of the [capstone-movielens.main.R](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L961) script.
:::

As we explained earlier in the [UME Model Regularization: *Pre-configuration*], we need to do some pre-configuration to determine a suitable range of $\lambda$ for subsequent fine-tuning of our current model.

As before, we are going to use the helper function [tune.model_param](#func.tune.model_param), but this time, passing another function as its argument [fn_tune.test.param_value](#func.tune.model_param.args.fn_tune.test.param_value): the function [regularize.test_lambda.UMG_effect.cv](#func.regularize.test_lambda.UMG_effect.cv) specifically design for the *UMGE Model*.

::: {.noteblock data-latex=""}
The functions [tune.model_param](#func.tune.model_param) and [regularize.test_lambda.UMG_effect.cv](#func.regularize.test_lambda.UMG_effect.cv) are described in the sections [Model Tuning Utils](#appndx_a.CHF.model_tuning_utils) and  [UMGE Model: Regularization], respectively, of [Appendix A](#appndx_a).
:::

The following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L978) performs this operation:
```{r main-script@l978, eval=FALSE}
lambdas <- seq(0, 0.2, 0.01)
cv.UMGE.preset.result <- 
  tune.model_param(lambdas, regularize.test_lambda.UMG_effect.cv)

put_log1("Preliminary regularization set-up of `lambda`s range for the UMGE Model has been completed
for the %1-Fold Cross Validation samples.",
CVFolds_N)
```
```{r}
str(cv.UMGE.preset.result)
cv.UMGE.preset.result$best_result
```

\newpage

Now, let's visualize the results of the $\lambda$ range pre-configuration using the following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1004):
``` {r main-script@l1004}
cv.UMGE.preset.result$tuned.result |>
  data.plot(title = TeX(r'[UMGE Model Regularization: $\lambda$ Range Pre-configuration]'),
              xname = "parameter.value", 
              yname = "RMSE", 
              xlabel = TeX(r'[$\lambda$]'), 
              ylabel = str_glue("Deviation from the best RMSE value (",
                                as.character(round(cv.UMGE.preset.result$best_result["best_RMSE"], 
                                                   digits = 7)),
                                ")"),
              normalize = TRUE)
```

::: {.noteblock data-latex=""}
In the code snippet above, we use the custom data visualization function [data.plot](#func.data.plot) described in section [Data Visualization Functions] of [Appendix A](#appndx_a).
:::

\newpage

#### UMGE Model Regularization: *Fine-tuning*
\

::: {.noteblock data-latex=""}
The complete version of the source code provided in this section can be found in the [UMGE Model Regularization: Fine-tuning](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1019) section of the [capstone-movielens.main.R](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1019) script on _GitHub_.
:::

We are now ready to perform the fine-tuning step of our model _regularization_ process to determine the best value for the $\lambda$ parameter.

The following [piece of code](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1020) prepares the interval of values for the $\lambda$ parameter, over which the operation has to be done:
```{r main-script@l1020, eval=FALSE}
endpoints <- 
  get_fine_tune.param.endpoints(cv.UMGE.preset.result$tuned.result)

UMG_effect.loop_starter <- c(endpoints["start"], 
                            endpoints["end"], 
                            8)
```
```{r, echo=FALSE}
writeLines("*** Values of the endpoints and the divisor for the interval of `lambda` values ***")
```
```{r}
UMG_effect.loop_starter
```

::: {.noteblock data-latex=""}
The helper function [get_fine_tune.param.endpoints](#func.get_fine_tune.param.endpoints) used in code snippet above is described in the sections [Model Tuning Utils](#appndx_a.CHF.model_tuning_utils) of [Appendix A](#appndx_a).
:::

And the next [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1029) below accomplishes the task of *fine-tuning* the model:
```{r main-script@l1029, eval=FALSE}
UMGE.rglr.fine_tune.cache.base_name <- "UMGE.rglr.fine-tuning"

UMGE.rglr.fine_tune.results <- 
  model.tune.param_range(UMG_effect.loop_starter,
                         UMGE.rglr.fine_tune.cache.path,
                         UMGE.rglr.fine_tune.cache.base_name,
                         regularize.test_lambda.UMG_effect.cv)

UMGE.rglr.fine_tune.RMSE.best <- UMGE.rglr.fine_tune.results$best_result["best_RMSE"]
```

::: {.noteblock data-latex=""}
The custom functions [model.tune.param_range](#func.model.tune.param_range) and [regularize.test_lambda.UMG_effect.cv](#func.regularize.test_lambda.UMG_effect.cv) used in the code snippet above are described in the sections [Model Tuning Utils](#appndx_a.CHF.model_tuning_utils) and  [UMGE Model: Regularization], respectively, of [Appendix A](#appndx_a).
:::

\newpage

Below are the results of fine-tuning the *UMGE Model*:

```{r, echo=FALSE}
writeLines("*** Path to the cache directory for intermediate fine-tuning results ***")
```
```{r}
UMGE.rglr.fine_tune.cache.path
```
```{r, echo=FALSE}
writeLines("*** Fine-tuning results object data structure ***")
```
```{r}
str(UMGE.rglr.fine_tune.results)
```
```{r, echo=FALSE}
writeLines("*** Fine-tuning: best results ***")
```
```{r}
UMGE.rglr.fine_tune.results$best_result
UMGE.rglr.fine_tune.RMSE.best
```

\newpage

The following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1048) provides a visual representation of the *fine-tuning results* we have just computed:
```{r main-script@l1048}
UMGE.rglr.fine_tune.results$tuned.result |>
  data.plot(title = "UMGE Model Regularization: Fine-tuned result",
              xname = "parameter.value",
              yname = "RMSE",
              xlabel = TeX(r'[$\lambda$]'),
              ylabel = str_glue("Deviation from the best RMSE value (",
                                as.character(round(UMGE.rglr.fine_tune.RMSE.best, digits = 7)),
                                ")"),
              normalize = TRUE)
```

::: {.noteblock data-latex=""}
Note that in the code snippet above, we use the custom data visualization function [data.plot](#func.data.plot) (described in section [Data Visualization Functions] of [Appendix A](#appndx_a)) with the argument [normalize](#func.data.plot.args.normalize) set to `TRUE`, which means that deviations from the minimum $y$ value are used to plot, rather than the $y$ values themselves.
:::

\newpage

#### UMGE Model Regularization: *Retraining on the `edx` with the best* $\lambda$
\

::: {.noteblock data-latex=""}
The complete version of the source code provided in this section are available in the [UMGE Model Regularization: Re-training with the best `lambda`](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1062) section of the [capstone-movielens.main.R](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1062) script on _GitHub_.
:::

Now, we can refine our *User+Movie+Genre Effect (UMGE) Model* by retraining on the entire `edx` dataset with the best value of the $\lambda$ parameter we just figured out (let's call it *Regularized User+Movie+Genre Effect Model* or *Regularized UMGE Model* for short), for the definitive *RMSE* calculation and use in subsequent models.

The following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1076) performs this operation:
```{r main-script@l1076, eval=FALSE}
best_result <- UMGE.rglr.fine_tune.results$best_result
UMGE.rglr.best_lambda <- best_result["param.best_value"]

put_log1("Re-training Regularized User+Movie+Genre Effect Model for the best `lambda`: %1...",
         UMGE.rglr.best_lambda)
  
rglr.UMG_effect <- edx.sgr |> train_user_movie_genre_effect(UMGE.rglr.best_lambda)
```

::: {.noteblock data-latex=""}
In the code snippet above we use the [train_user_movie_genre_effect](#func.train_user_movie_genre_effect) function described in section [UMGE Model: Utility Functions] of [Appendix A](#appndx_a).
:::

```{r, echo=FALSE}
writeLines("*** The Best UMG Effect Fine-tuning Results ***")
```
```{r}
UMGE.rglr.fine_tune.results$best_result
```

```{r, echo=FALSE}
writeLines("*** Regularized UMG Effect Structure ***")
```
```{r}
str(rglr.UMG_effect)

print_log1("Regularized UMGE Model has been re-trained for the best `lambda`: %1.",
         UMGE.rglr.best_lambda)
```

\newpage

Now, we are ready to construct predictors and calculate the *RMSE* score for the ultimately *Regularized UMGE Model* using the following [line of code](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1087): 
```{r main-script@l1087, eval=FALSE}
  rglr.UMG_effect.RMSE <- calc_user_movie_genre_effect_RMSE.cv(rglr.UMG_effect)
```
```{r}
print_log1("The best RMSE for the UMGE Model after being regularized: %1",
         rglr.UMG_effect.RMSE)
```

::: {.noteblock data-latex=""}
In the code snippet above, we use the [calc_user_movie_genre_effect_RMSE.cv](#func.calc_user_movie_genre_effect_RMSE.cv) function described in section [UMGE Model: Utility Functions] of [Appendix A](#appndx_a). 
:::

Finally, we add the definitive *RMSE* value obtained above to our *Result Table* and print the table using the following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1114):
```{r main-script@l1114, eval=FALSE}
RMSEs.ResultTibble.rglr.UMGE <- RMSEs.ResultTibble.UMGE |> 
  RMSEs.AddRow("Regularized User+Movie+Genre Effect Model", 
               rglr.UMG_effect.RMSE,
               comment = "Computed for `lambda` = %1" |>
                 msg.glue(UMGE.rglr.best_lambda))
```
```{r}
RMSE_kable(RMSEs.ResultTibble.rglr.UMGE)
```

::: {.noteblock data-latex=""}
In the code snippet above, we use the [RMSEs.AddRow](#func.RMSEs.AddRow) and [RMSE_kable](#func.RMSE_kable) functions described in section [Result RMSEs Tibble Functions] of [Appendix A](#appndx_a).
:::

As we can see, the current model still doesn't show any significant improvement after *Regularization*, even though the data analysis we made earlier in the [Movie Genres Effect Analysis] section showed strong evidence of a genre effect.

Apparently, we need a better model to account for a genre effect more efficiently. 

\newpage

