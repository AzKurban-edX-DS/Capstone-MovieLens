## User+Movie+Genre+Year+SmoothedDay Effect (UMGYDE) Model
\

### Mathematical Description of the UMGYDE Model
\

If we define $d_{i,j}$ as the _number of days since the earliest record_ in the `edx` dataset for movie $j$ rated by user $i$, then the formula \@ref(eq:UMGYE-model) describing the _UMGYE Model_, for the current model, takes the form:

\begin{equation}
Y_{i,j} = \mu + \alpha_i + \beta_j + g_{i,j} + \gamma(v_{i,j}) + s(d_{i,j}) + \varepsilon_{i,j}
(\#eq:UMGYDE-model)
\end{equation}

with $s$ a _smoothed day_ function of $d_{i,j}$

Therefore, the formula \@ref(eq:year-effect) for calculation the prediction of a _year effect_ as a residual, for a _smoothed day effect_ 
$$
\hat{s}(d_{i,j}) = s(d_{i,j}) + \varepsilon_{i,j}
$$

takes the following form:

\begin{equation}
\hat{s}(d_{i,j}) = Y_{i,j} - (\mu + \alpha_i + \beta_j + g_{i,j} + \gamma(v_{i,j}))
(\#eq:smoothed-day-effect)
\end{equation}

\newpage

### UMGYDE Model Building with `loess` Default Parameters
\

::: {.noteblock data-latex=""}
The complete source code of building and training the current model is available in the [UMGYDEM Training with default parameters](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1477) section of the [capstone-movielens.main.R](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1477) script on _GitHub_.
:::

We are going to use the custom helper function ([train_UMGY_SmoothedDay_effect.cv](#func.train_UMGY_SmoothedDay_effect.cv) (described in section [UMGYDE Model: Utility Functions] of [Appendix A](#appndx_a)) specifically designed to train the *UMGYDE Model*, which under the hood implicitly calls the [stats::loess](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/loess) `R` function, passing its `degree` and `span` parameters values taken from the caller's [degree](#func.train_UMGY_SmoothedDay_effect.cv.args.degree) and [span](#func.train_UMGY_SmoothedDay_effect.cv.args.span) arguments, respectively.

We will start by calling the [train_UMGY_SmoothedDay_effect.cv](#func.train_UMGY_SmoothedDay_effect.cv) with default argument values, which, in addition to not use *regularization technique* yet (which will be used in further training later for the current model), means that the [loess](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/loess) function will be internally called with `degree = 1` and `span = 0.75` argument values.

Below is the [line of code](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1495) that trains our model with the default `degree` and `span` parameter values with the use of *K-Fold Cross Validation*, where the $K$ is the length of the [`edx_CV` Object] (described in detail in [Appendix B: Models Training Datasets]) to which the *K-Fold Cross-Validation* is applied (in *this Project*, we use $K = 5$):
```{r main-script@l1495, eval=FALSE}
  cv.UMGYDE.default_params <- train_UMGY_SmoothedDay_effect.cv()
```
```{r}
str(cv.UMGYDE.default_params)
```

\newpage

The following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1521) provides a visual representation of the *Smoothed Day Effect* data we have just computed:
```{r main-script@l1521}
cv.UMGYDE.default_params |>
  ggplot(aes(x = days)) +
  geom_point(aes(y = de), size = 3, alpha = .5, color = "grey") + 
  geom_line(aes(y = de_smoothed), color = "red")
```

Now, let's construct predictors and calculate the *RMSE* score for the *current model* using the following [line of code](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1531): 
```{r main-script@l1531, eval=FALSE}
cv.UMGYDE.default_params.RMSE <- cv.UMGYDE.default_params |>
  calc_UMGY_SmoothedDay_effect.RMSE.cv()
```
```{r}
cv.UMGYDE.default_params.RMSE
```

::: {.noteblock data-latex=""}
In the code snippets above, we use the [calc_UMGY_SmoothedDay_effect.RMSE.cv](#func.calc_UMGY_SmoothedDay_effect.RMSE.cv) custom helper function described in section [UMGYDE Model: Utility Functions] of [Appendix A](#appndx_a).
:::

\newpage

Finally, we add the *RMSE* value obtained above to our *Result Table* and print the table using the following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1542):
```{r main-script@l1542, eval=FALSE}
RMSEs.ResultTibble.UMGYDE <- RMSEs.ResultTibble.rglr.UMGYE |> 
  RMSEs.AddRow("UMGYDE (Default) Model", 
               cv.UMGYDE.default_params.RMSE,
               comment = "User+Movie+Genre+Year+Day Effect (UMGYDE) Model 
computed using `stats::loess` function with `degree=1` & `span=0.75` parameter values.")
```
```{r}
RMSE_kable(RMSEs.ResultTibble.UMGYDE)
```

::: {.noteblock data-latex=""}
In the code snippet above we also use the [RMSEs.AddRow](#func.RMSEs.AddRow) and [RMSE_kable](#func.RMSE_kable) functions described in section [Result RMSEs Tibble Functions] of [Appendix A](#appndx_a).
:::

Unfortunately, with the default parameters, we obtained an even worse result than before.
Let's tune the current model by adjusting the `degree` and `span` parameters and see what we get.

\newpage

### UMGYDE Model Tuning by `degree` and `span` Parameters
\

::: {.noteblock data-latex=""}
The complete source code of the solution described in this section is available in the [UMGYDE Model Tuning by `span` & `degree` parameters](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1553) section of the [capstone-movielens.main.R](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1553) script on _GitHub_.
:::

Since the `degree` parameter can only take three discrete values, 0, 1, and 2, we will perform the tuning in three stages - one for each value.

In addition, we will divide each stage into the following two steps for tuning the model by the `span` parameter:

1. **Pre-configuration:**  Preliminary determination of the optimal range of the `span` parameter values for the *K-Fold Cross-Validation* samples, where the $K$ is the length of the [`edx_CV` Object] (described in detail in [Appendix B: Models Training Datasets]) to which the *K-Fold Cross-Validation* is applied (in *this Project*, we use $K = 5$);

2. **Fine-tuning:** Determining the best value of the `span` parameter with the highest possible accuracy that minimizes the *RMSE* score for the model.

Finally, we will retrain the model on the entire `edx` dataset with the best `degree` and `span` values determined by the tuning result.

\newpage

#### UMGYDE Model Tuning: Stage 1 (`degree = 0`)
\

##### Pre-configuration: Optimal `span` Range Determination (`degree = 0`)
\

::: {.noteblock data-latex=""}
The complete source code of the solution described in this section is available in the [UMGYDE Model Tuning: Pre-configuration (`degree = 0`)](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1558) section of the [capstone-movielens.main.R](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1558) script on _GitHub_.
:::

The following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1578) determines the optimal range of `span` for the further model tuning when `degree = 0`:
```{r main-script@l1578, eval=FALSE}
  spans <- seq(0.0005, 1, 0.001)
  lss.UMGYDE.preset.degree0.result <- 
    tune.model_param(spans, train_UMGY_SmoothedDay_effect.RMSE.cv.degree0)
```

::: {.noteblock data-latex=""}
In the code snippet above, we use the following functions described in [Appendix A](#appndx_a): 
  
  - [tune.model_param](#func.tune.model_param) (described in section [Model Tuning Utils](#appndx_a.CHF.model_tuning_utils)) to select the best value of the *tuning parameter* (`span` in our case) from the given sequence of the *parameter values* passed in the [param_values](#func.tune.model_param.args.param_values) argument.

  - [train_UMGY_SmoothedDay_effect.RMSE.cv.degree0](#func.train_UMGY_SmoothedDay_effect.RMSE.cv.degree0) (described in section [UMGYDE Model: Tuning `loess` Params]) used as an auxiliary function passed (in the [fn_tune.test.param_value](#func.tune.model_param.args.fn_tune.test.param_value) argument) to the [tune.model_param](#func.tune.model_param) to test the *UMGYDE Model* with the [loess](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/loess) `degree` parameter set to $0$.
  
:::

```{r}
str(lss.UMGYDE.preset.degree0.result)
```


\newpage

The [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1609) below provides a visual representation of the dependence of the *RMSE* value on the [loess](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/loess) `span` parameter value over the selected interval, with the parameter `degree = 0`, as we have figured out in this step of tuning:
```{r main-script@l1609}
plt.title = "UMGYDE Model, `loess` function args: range of `span` values for `degree = 0`"
lss.UMGYDE.preset.degree0.result$tuned.result |>
  data.plot(plt.title,
              xname = "parameter.value", 
              yname = "RMSE", 
              xlabel = "spans", 
              ylabel = "RMSE")
rm(plt.title)
```

::: {.noteblock data-latex=""}
In the code snippet above, we use the custom data visualization function [data.plot](#func.data.plot) described in section [Data Visualization Functions] of [Appendix A](#appndx_a).
:::

\newpage

##### UMGYDE Model Fine-tuning (`degree = 0`)
\

::: {.noteblock data-latex=""}
The complete source code of the solution described in this section is available in the [UMGYDE Model Fine-tuning (`degree = 0`)](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1624) section of the [capstone-movielens.main.R](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1624) script on _GitHub_.
:::

The following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1625) performs the *fine-tuning* of the *UMGYDE Model* by precise selection of the [loess](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/loess) `span` parameter with the `degree` parameter set to $0$:
```{r main-script@l1625, eval=FALSE}
lss.fine_tune.loop_starter <- 
  c(lss.UMGYDE.preset.degree0.result$tuned.result$parameter.value[1], 
    lss.UMGYDE.preset.degree0.result$tuned.result$parameter.value[3], 
    8)

cache_file.base_name <- "UMGYDE.degree0.tuning-span"

lss.UMGYDE.fine_tune.degree0.result <- 
  model.tune.param_range(lss.fine_tune.loop_starter,
                         UMGYDE.fine_tune.degree0.data.path,
                         cache_file.base_name,
                         train_UMGY_SmoothedDay_effect.RMSE.cv.degree0)
```

::: {.noteblock data-latex=""}
In the code snippet above, we use the following functions described in [Appendix A: Support Functions]: 
  
  - [model.tune.param_range](#func.model.tune.param_range) (described in section [Model Tuning Utils](#appndx_a.CHF.model_tuning_utils)) to enhance the accuracy of the *tuning parameter best value* using the *best value neighborhood* information passed in the [loop_starter](#func.model.tune.param_range.args.loop_starter) argument.

  - [train_UMGY_SmoothedDay_effect.RMSE.cv.degree0](#func.train_UMGY_SmoothedDay_effect.RMSE.cv.degree0) (already mentioned in the previous section) used as an auxiliary function passed (in the [fn_tune.test.param_value](#func.model.tune.param_range.args.fn_tune.test.param_value) argument) to the [model.tune.param_range](#func.model.tune.param_range) to test the *UMGYDE Model* with the [loess](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/loess) `degree` parameter set to $0$.
  
:::

```{r}
lss.fine_tune.loop_starter
str(lss.UMGYDE.fine_tune.degree0.result)
```

\newpage

The [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1651) below provides a visual representation of the dependence of the *RMSE* value on the [loess](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/loess) `span` parameter value over the neighborhood of its *best value* (when the parameter `degree = 0`), which we have determined in this (*fine-tuning*) step:
```{r main-script@l1651}
plt.title = "Fine-tuned UMGYDE Model with `loess` parameter: `degree` = 0"

lss.UMGYDE.fine_tune.degree0.result$tuned.result |>
  data.plot(plt.title, 
              xname = "parameter.value", 
              yname = "RMSE", 
              xlabel = "spans", 
              ylabel = "RMSE")
rm(plt.title)
```

::: {.noteblock data-latex=""}
In the code snippet above, we use the custom data visualization function [data.plot](#func.data.plot) described in section [Data Visualization Functions] of [Appendix A](#appndx_a).
:::

\newpage

Now, we can add the best *RMSE* figured out for the *UMGYDE Fine-tuned Model* with the [loess](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/loess) `degree = 0` (let's call it *Tuned UMGYDE.d0 Model*) to our *Result Table* and print the table using the following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1662):
```{r main-script@l1662, eval=FALSE}
RMSEs.ResultTibble.UMGYDE0 <- RMSEs.ResultTibble.UMGYDE |> 
  RMSEs.AddRow("Tuned UMGYDE.d0 Model", 
               lss.UMGYDE.fine_tune.degree0.result.best_RMSE,
               comment = "UMGYDE Model computed using function call: `loess(degree = 0, span = %1)`" |>
                 msg.glue(lss.UMGYDE.fine_tune.degree0.result.best_span))
```
```{r}
RMSE_kable(RMSEs.ResultTibble.UMGYDE0)
```

::: {.noteblock data-latex=""}
In the code snippet above we use the [RMSEs.AddRow](#func.RMSEs.AddRow) and [RMSE_kable](#func.RMSE_kable) functions described in section [Result RMSEs Tibble Functions] of [Appendix A](#appndx_a).
:::

\newpage

#### UMGYDE Model Tuning: Stage 2 (`degree = 1`)
\

##### Pre-configuration: Optimal `span` Range Determination (`degree = 1`)
\

::: {.noteblock data-latex=""}
The complete source code of the solution described in this section is available in the [UMGYDE Model Tuning: Pre-configuration  (`degree = 1`)](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1675) section of the [capstone-movielens.main.R](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1675) script on _GitHub_.
:::

Below is the [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1695) that determines the optimal range of `span` for the further model tuning when `degree = 1`:
```{r main-script@l1695, eval=FALSE}
  spans <- seq(0.0005, 1, 0.001)
  lss.UMGYDE.preset.degree1.result <- 
    tune.model_param(spans, train_UMGY_SmoothedDay_effect.RMSE.cv.degree1)
```

::: {.noteblock data-latex=""}
In the code snippet above, we use the following functions described in [Appendix A: Support Functions]: 
  
  - [tune.model_param](#func.tune.model_param) (described in section [Model Tuning Utils](#appndx_a.CHF.model_tuning_utils)) to select the best value of the *tuning parameter* (`span` in our case) from the given sequence of the *parameter values* passed in the [param_values](#func.tune.model_param.args.param_values) argument.

  - [train_UMGY_SmoothedDay_effect.RMSE.cv.degree1](#func.train_UMGY_SmoothedDay_effect.RMSE.cv.degree1) (described in section [UMGYDE Model: Tuning `loess` Params]) used as an auxiliary function passed (in the [fn_tune.test.param_value](#func.tune.model_param.args.fn_tune.test.param_value) argument) to the [tune.model_param](#func.tune.model_param) to test the *UMGYDE Model* with the [loess](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/loess) `degree` parameter set to $1$.
  
:::

```{r}
str(lss.UMGYDE.preset.degree1.result)
```

\newpage

The [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1726) below provides a visual representation of the dependence of the *RMSE* value on the [loess](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/loess) `span` parameter value over the selected interval, with the parameter `degree = 1`, as we have figured out in this step of tuning:
```{r main-script@l1726}
lss.UMGYDE.preset.degree1.result$tuned.result |>
  data.plot(title = "UMGYDE Model, `loess` function args: range of `span` values for `degree = 1`",
              xname = "parameter.value", 
              yname = "RMSE", 
              xlabel = "spans", 
              ylabel = "RMSE")
```

::: {.noteblock data-latex=""}
In the code snippet above, we use the custom data visualization function [data.plot](#func.data.plot) described in section [Data Visualization Functions] of [Appendix A](#appndx_a).
:::

\newpage

##### UMGYDE Model Fine-tuning (`degree = 1`)
\

::: {.noteblock data-latex=""}
The complete source code of the solution described in this section is available in the [UMGYDE Model Fine-tuning (`degree = 1`)](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1738) section of the [capstone-movielens.main.R](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1738) script on _GitHub_.
:::

The following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1739) performs the *fine-tuning* of the *UMGYDE Model* by precise selection of the [loess](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/loess) `span` parameter with the `degree` parameter set to $1$:
```{r main-script@l1739, eval=FALSE}
lss.fine_tune.loop_starter <- 
  c(lss.UMGYDE.preset.degree1.result$tuned.result$parameter.value[1], 
    lss.UMGYDE.preset.degree1.result$tuned.result$parameter.value[3], 
    8)

cache_file.base_name <- "UMGYDE.degree1.tuning-span"

lss.UMGYDE.fine_tune.degree1.result <- 
  model.tune.param_range(lss.fine_tune.loop_starter,
                         UMGYDE.fine_tune.degree1.data.path,
                         cache_file.base_name,
                         train_UMGY_SmoothedDay_effect.RMSE.cv.degree1)
```

::: {.noteblock data-latex=""}
In the code snippet above, we use the following functions described in [Appendix A](#appndx_a): 
  
  - [model.tune.param_range](#func.model.tune.param_range) (described in section [Model Tuning Utils](#appndx_a.CHF.model_tuning_utils)) to enhance the accuracy of the *tuning parameter best value* using the *best value neighborhood* information passed in the [loop_starter](#func.model.tune.param_range.args.loop_starter) argument.

  - [train_UMGY_SmoothedDay_effect.RMSE.cv.degree1](#func.train_UMGY_SmoothedDay_effect.RMSE.cv.degree1) (already mentioned in the previous section) used as an auxiliary function passed (in the [fn_tune.test.param_value](#func.model.tune.param_range.args.fn_tune.test.param_value) argument) to the [model.tune.param_range](#func.model.tune.param_range) to test the *UMGYDE Model* with the [loess](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/loess) `degree` parameter set to $1$.
  
:::

```{r}
lss.fine_tune.loop_starter
str(lss.UMGYDE.fine_tune.degree1.result)
```

\newpage


The [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1765) below provides a visual representation of the dependence of the *RMSE* value on the [loess](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/loess) `span` parameter value over the neighborhood of its *best value* (when the parameter `degree = 1`), which we have determined in this (*fine-tuning*) step:
```{r main-script@l1765}
lss.UMGYDE.fine_tune.degree1.result$tuned.result |>
  data.plot(title = "Fine-tuned UMGYDE Model with `loess` parameter: `degree = 1`", 
                             xname = "parameter.value", 
                             yname = "RMSE", 
                             xlabel = "spans", 
                             ylabel = "RMSE")
```

::: {.noteblock data-latex=""}
In the code snippet above, we use the custom data visualization function [data.plot](#func.data.plot) described in section [Data Visualization Functions] of [Appendix A](#appndx_a).
:::

\newpage

Now, we can add the best *RMSE* figured out for the *UMGYDE Fine-tuned Model* with the [loess](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/loess) `degree = 1` (let's call it *Tuned UMGYDE.d1 Model*) to our *Result Table* and print the table using the following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1773):
```{r main-script@l1773, eval=FALSE}
RMSEs.ResultTibble.UMGYDE1 <- RMSEs.ResultTibble.UMGYDE0 |> 
  RMSEs.AddRow("Tuned UMGYDE.d1 Model", 
               lss.UMGYDE.fine_tune.degree1.result.best_RMSE,
               comment = "UMGYDE Model computed using function call: `loess(degree = 1, span = %1)`" |>
                 msg.glue(lss.UMGYDE.fine_tune.degree1.result.best_span))
```
```{r}
RMSE_kable(RMSEs.ResultTibble.UMGYDE1)
```

::: {.noteblock data-latex=""}
In the code snippet above we use the [RMSEs.AddRow](#func.RMSEs.AddRow) and [RMSE_kable](#func.RMSE_kable) functions described in section [Result RMSEs Tibble Functions] of [Appendix A](#appndx_a).
:::

\newpage

#### UMGYDE Model Tuning: Stage 3 (`degree = 2`)
\

##### Pre-configuration: Optimal `span` Range Determination (`degree = 2`)
\

::: {.noteblock data-latex=""}
The complete source code of the solution described in this section is available in the [UMGYDE Model Tuning: Pre-configuration (`degree = 2`)](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1787) section of the [capstone-movielens.main.R](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1787) script on _GitHub_.
:::

Below is the [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1807) that determines the optimal range of `span` for the further model tuning when `degree = 2`:
```{r main-script@l1807, eval=FALSE}
  spans <- seq(0.0005, 1, 0.001)
  lss.UMGYDE.preset.degree2.result <- 
    tune.model_param(spans, train_UMGY_SmoothedDay_effect.RMSE.cv.degree2)
```

::: {.noteblock data-latex=""}
In the code snippet above, we use the following functions described in [Appendix A](#appndx_a): 
  
  - [tune.model_param](#func.tune.model_param) (described in section [Model Tuning Utils](#appndx_a.CHF.model_tuning_utils)) to select the best value of the *tuning parameter* (`span` in our case) from the given sequence of the *parameter values* passed in the [param_values](#func.tune.model_param.args.param_values) argument.

  - [train_UMGY_SmoothedDay_effect.RMSE.cv.degree2](#func.train_UMGY_SmoothedDay_effect.RMSE.cv.degree2) (described in section [UMGYDE Model: Tuning `loess` Params]) used as an auxiliary function passed (in the [fn_tune.test.param_value](#func.tune.model_param.args.fn_tune.test.param_value) argument) to the [tune.model_param](#func.tune.model_param) to test the *UMGYDE Model* with the [loess](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/loess) `degree` parameter set to $2$.
  
:::

```{r}
str(lss.UMGYDE.preset.degree2.result)
```

\newpage

The [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1838) below provides a visual representation of the dependence of the *RMSE* value on the [loess](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/loess) `span` parameter value over the selected interval, with the parameter `degree = 2`, as we have figured out in this step of tuning:
```{r main-script@l1838}
lss.UMGYDE.preset.degree2.result$tuned.result |>
  data.plot(title = "UMGYDE Model, `loess` function args: range of `span` values for `degree = 2`",
              xname = "parameter.value", 
              yname = "RMSE", 
              xlabel = "spans", 
              ylabel = "RMSE")
```

::: {.noteblock data-latex=""}
In the code snippet above, we use the custom data visualization function [data.plot](#func.data.plot) described in section [Data Visualization Functions] of [Appendix A](#appndx_a).
:::

\newpage

##### UMGYDE Model Fine-tuning (`degree = 2`)
\

::: {.noteblock data-latex=""}
The complete source code of the solution described in this section is available in the [UMGYDE Model Fine-tuning (`degree = 2`)](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1850) section of the [capstone-movielens.main.R](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1850) script on _GitHub_.
:::

The following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1851) performs the *fine-tuning* of the *UMGYDE Model* by precise selection of the [loess](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/loess) `span` parameter with the `degree` parameter set to $2$:
```{r main-script@l1851, eval=FALSE}
lss.fine_tune.loop_starter <- 
  c(lss.UMGYDE.preset.degree2.result$tuned.result$parameter.value[1], 
    lss.UMGYDE.preset.degree2.result$tuned.result$parameter.value[3], 
    8)

cache_file.base_name <- "UMGYDE.degree2.tuning-span"

lss.UMGYDE.fine_tune.degree2.result <- 
  model.tune.param_range(lss.fine_tune.loop_starter,
                         UMGYDE.fine_tune.degree2.data.path,
                         cache_file.base_name,
                         train_UMGY_SmoothedDay_effect.RMSE.cv.degree2)
```

::: {.noteblock data-latex=""}
In the code snippet above, we use the following functions described in [Appendix A: Support Functions]: 
  
  - [model.tune.param_range](#func.model.tune.param_range) (described in section [Model Tuning Utils](#appndx_a.CHF.model_tuning_utils)) to enhance the accuracy of the *tuning parameter best value* using the *best value neighborhood* information passed in the [loop_starter](#func.model.tune.param_range.args.loop_starter) argument.

  - [train_UMGY_SmoothedDay_effect.RMSE.cv.degree2](#func.train_UMGY_SmoothedDay_effect.RMSE.cv.degree2) (already mentioned in the previous section) used as an auxiliary function passed (in the [fn_tune.test.param_value](#func.model.tune.param_range.args.fn_tune.test.param_value) argument) to the [model.tune.param_range](#func.model.tune.param_range) to test the *UMGYDE Model* with the [loess](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/loess) `degree` parameter set to $2$.
  
:::

```{r}
lss.fine_tune.loop_starter
str(lss.UMGYDE.fine_tune.degree2.result)
```

\newpage

The [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1877) below provides a visual representation of the dependence of the *RMSE* value on the [loess](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/loess) `span` parameter value over the neighborhood of its *best value* (when the parameter `degree = 2`), which we have determined in this (*fine-tuning*) step. 
Since the left endpoint value of the *RMSE* range has much smaller deviation from the minimum than the value of the right endpoint, for visual clarity, we plot the left part of the graph once more on an *enlarged scale* (below the main graph):
```{r main-script@l1877}
lss.UMGYDE.fine_tune.degree2.result$tuned.result |>
  data.plot.left_detailed(title = "Fine-tuned UMGYDE Model with `loess` parameter: `degree = 2`", 
                             title.left = "Left Part of the Chart Above (Zoomed in)",
                             left.n = 8,
                             xname = "parameter.value", 
                             yname = "RMSE", 
                             xlabel1 = "spans", 
                             ylabel1 = "RMSE")
```

::: {.noteblock data-latex=""}
In the code snippet above, we use the custom data visualization function [data.plot.left_detailed](#func.data.plot.left_detailed) described in section [Data Visualization Functions] of [Appendix A](#appndx_a).
:::

\newpage

Now, we can add the best *RMSE* value figured out for the *UMGYDE Fine-tuned Model* with the [loess](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/loess) `degree = 2` (let's call it *Tuned UMGYDE.d2 Model*) to our *Result Table* and print the table using the following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1887):
```{r main-script@l1887, eval=FALSE}
RMSEs.ResultTibble.UMGYDE2 <- RMSEs.ResultTibble.UMGYDE1 |> 
  RMSEs.AddRow("Tuned UMGYDE.d2 Model", 
               lss.UMGYDE.fine_tune.degree2.result.best_RMSE,
               comment = "UMGYDE Model computed using function call: `loess(degree = 2, span = %1)`" |>
                 msg.glue(lss.UMGYDE.fine_tune.degree2.result.best_span))
```
```{r}
RMSE_kable(RMSEs.ResultTibble.UMGYDE2)
```

::: {.noteblock data-latex=""}
In the code snippet above we use the [RMSEs.AddRow](#func.RMSEs.AddRow) and [RMSE_kable](#func.RMSE_kable) functions described in section [Result RMSEs Tibble Functions] of [Appendix A](#appndx_a).
:::

\newpage

#### UMGYDE Model Tuning: Re-training on the `edx` with the Best Params
\

::: {.noteblock data-latex=""}
The complete version of the source code provided in this section are available in the [UMGYDE Tuned Model: Retraining with the best params](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1900) section of the [capstone-movielens.main.R](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1900) script on _GitHub_.
:::

Now, we can refine the current model by retraining on the entire `edx` dataset with the best values of the [loess](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/loess) parameters `degree` and `span` we just figured out (let's call it *Tuned UMGYDE Best Model*), for the definitive _RMSE_ calculation and use in subsequent models:

The following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1913) performs this operation:
```{r main-script@l1913, eval=FALSE}
# The Best Parameters and RMSE Value 
lss.best_results <- data.frame(degree = degree, 
                         span = c(lss.UMGYDE.fine_tune.degree0.result.best_span,
                                  lss.UMGYDE.fine_tune.degree1.result.best_span,
                                  lss.UMGYDE.fine_tune.degree2.result.best_span),
                         
                         RMSE = c(lss.UMGYDE.fine_tune.degree0.result.best_RMSE, 
                                  lss.UMGYDE.fine_tune.degree1.result.best_RMSE,
                                  lss.UMGYDE.fine_tune.degree2.result.best_RMSE))

lss.best_RMSE.idx <- which.min(lss.best_results$RMSE)


lss.UMGYDE.best_params <- 
  c(degree =  lss.best_results[lss.best_RMSE.idx, "degree"],  # 1
    span = lss.best_results[lss.best_RMSE.idx, "span"], # 0.00087,
    RMSE = lss.best_results[lss.best_RMSE.idx, "RMSE"]) # 0.8568619

lss.best_degree <- lss.UMGYDE.best_params["degree"]
lss.best_span <- lss.UMGYDE.best_params["span"]
lss.best_RMSE <- lss.UMGYDE.best_params["RMSE"]

put_log2("Re-training model using `loess` function with the best parameters: 
span = %1, degree = %2", lss.best_span, lss.best_degree)

lss.UMGYD_effect <- edx |> 
  train_UMGY_SmoothedDay_effect(lss.best_degree, lss.best_span)
```

::: {.noteblock data-latex=""}
In the code snippet above we use the [train_UMGY_SmoothedDay_effect](#func.train_UMGY_SmoothedDay_effect) custom helper function described in section [UMGYDE Model: Utility Functions] of [Appendix A](#appndx_a).
:::

\newpage

```{r}
lss.UMGYDE.best_params
str(lss.UMGYD_effect)
```

The following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L1993) provides a visual representation of the final *Smoothed Day Effect* data we have just obtained:
```{r main-script@l1993}
lss.UMGYD_effect |>
  ggplot(aes(x = days)) +
  geom_point(aes(y = de), size = 3, alpha = .5, color = "grey") + 
  geom_line(aes(y = de_smoothed), color = "red")
```

::: {.noteblock data-latex=""}
It should be noted, however, that the graph above is not as smooth as when training the model with default [loess] parameters (`degree` and `span`), although we have now obtained a better (*RMSE*) result.
:::

\newpage

Now, we are ready to construct predictors and calculate the *RMSE* score for the ultimately *Tuned UMGYDE Best Model* using the following [line of code](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2007): 
```{r main-script@l2007, eval=FALSE}
lss.UMGYD_effect.RMSE <- calc_UMGY_SmoothedDay_effect.RMSE.cv(lss.UMGYD_effect)
```
```{r}
lss.UMGYD_effect.RMSE
```

::: {.noteblock data-latex=""}
In the code snippets above, we use the [calc_UMGY_SmoothedDay_effect.RMSE.cv](#func.calc_UMGY_SmoothedDay_effect.RMSE.cv) custom helper function described in section [UMGYDE Model: Utility Functions] of [Appendix A](#appndx_a).
:::

Finally, we add the *RMSE* value obtained above for the fully tuned model (let's call it *Tuned UMGYDE Best Model*) to our *Result Table* and print the table using the following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2024):
```{r main-script@l2024, eval=FALSE}
RMSEs.ResultTibble.UMGYDE.tuned <- RMSEs.ResultTibble.UMGYDE2 |> 
  RMSEs.AddRow("Tuned UMGYDE Best Model", 
               lss.UMGYD_effect.RMSE,
               comment = "UMGYDE Model computed using `loess` function call with the best degree & span values.")
```
```{r}
RMSE_kable(RMSEs.ResultTibble.UMGYDE.tuned)
```

::: {.noteblock data-latex=""}
In the code snippet above we use the [RMSEs.AddRow](#func.RMSEs.AddRow) and [RMSE_kable](#func.RMSE_kable) functions described in section [Result RMSEs Tibble Functions] of [Appendix A](#appndx_a).
:::

Now, as the final stage of the tuning process, let's *regularize* our model (as we did with the previous models).

\newpage

### UMGYDE Model Regularization
\

::: {.noteblock data-latex=""}
The complete version of the source code provided in this section can be found in the [UMGYDE Model Regularization](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2039) section of the [capstone-movielens.main.R](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2039) script.
:::

We begin this section with the concept's mathematical description presented below in the subsection [UMGYDE Model Regularization: *Mathematical Description*].

Next, we will implement the *UMGYDE Model Regularization* in the following three steps:

  1. **Pre-configuration:** (Described in subsection [UMGYDE Model Regularization: *Pre-configuration*]) Preliminary determination of the optimal range of *regularization parameter* $\lambda$ values for the *K-Fold Cross-Validation* samples, where the $K$ is the length of the [`edx_CV` Object] (described in detail in [Appendix B: Models Training Datasets]) to which the *K-Fold Cross-Validation* is applied (in *this Project*, we use $K = 5$);
  
  2. **Fine-tuning:** (Described in the subsection [UMGYDE Model Regularization: *Fine-tuning*]) Determining the best value of $\lambda$ with the highest possible accuracy that minimizes the *RMSE* score for the model.

  3. **Retraining:** (Described in subsection [UMGYDE Model Regularization: *Retraining on the `edx` with the best* $\lambda$]) Retraining the model on the entire `edx` dataset with the best value of $\lambda$ determined in the previous step.

#### UMGYDE Model Regularization: *Mathematical Description*
\

We have already explained the idea of the *Linear Model Regularization* earlier in section [UME Model Regularization]. We have also seen how the formula \@ref(eq:ME-penalty) for adding a penalty to the _UME Model_ is transformed into the formula \@ref(eq:GE-penalty) for the _UMGE Model_ and then into the formula \@ref(eq:YE-penalty) for the _UMGYE Model_. For the current model, this formula takes the form:

\begin{equation}
\sum_{i,j} \left(y_{u,i} - \mu - \alpha_i - \beta_j - g_{i,j} - \gamma(v_{i,j}) - s(d_{i,j})\right)^2 + \lambda \sum_{i,j} s(d_{i,j})^2
(\#eq:DE-penalty)
\end{equation}

And the formula \@ref(eq:YE-regularized) for calculating the values of the _treatment effect_ that minimizes the equation will take the form:

\begin{equation}
\hat{s}(d_{i,j}, \lambda) = \frac{1}{\lambda + n_d} \sum_{r=1}^{n_{d}} \left(Y_{i,j} - \mu - \alpha_i - \beta_j - g_{i,j} - \gamma(v_{i,j})\right)
(\#eq:DE-regularized)
\end{equation}

where $n_d$ is the number of ratings made on the day $d$. 

\newpage

#### UMGYDE Model Regularization: *Pre-configuration*
\

::: {.noteblock data-latex=""}
The complete version of the source code shown in this section is available in the [UMGYDE Model Regularization: Pre-configuration](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2053) section of the [capstone-movielens.main.R](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2053) script on _GitHub_.
:::

As for previous models, we will use the function [tune.model_param](#func.tune.model_param) passing in the [fn_tune.test.param_value](#func.tune.model_param.args.fn_tune.test.param_value) argument the model-specific helper function (this time designed for the *UMGYDE Model*): [regularize.test_lambda.UMGYD_effect.cv](#func.regularize.test_lambda.UMGYD_effect.cv).

::: {.noteblock data-latex=""}
The functions [tune.model_param](#func.tune.model_param) and [regularize.test_lambda.UMGYD_effect.cv](#func.regularize.test_lambda.UMGYD_effect.cv) are described in the sections [Model Tuning Utils](#appndx_a.CHF.model_tuning_utils) and  [UMGYE Model: Regularization], respectively, of [Appendix A](#appndx_a).
:::

The following [piece of code](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2070) performs this operation:
```{r main-script@l, eval=FALSE}
  lambdas <- seq(0, 256, 16)
  cv.UMGYDE.preset.result <- 
    tune.model_param(lambdas, regularize.test_lambda.UMGYD_effect.cv)
```
```{r}
str(cv.UMGYDE.preset.result)
cv.UMGYDE.preset.result$best_result
```

\newpage

Now, let's visualize the results of the $\lambda$ range pre-configuration using the following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2098):
``` {r main-script@l2098}
cv.UMGYDE.preset.result$tuned.result |>
  data.plot(title = TeX(r'[UMGYDE Model Regularization: $\lambda$ Range Pre-configuration]'),
              xname = "parameter.value", 
              yname = "RMSE", 
              xlabel = TeX(r'[$\lambda$]'), 
              ylabel = "RMSE")
```

::: {.noteblock data-latex=""}
In the code snippet above, we use the custom data visualization function [data.plot](#func.data.plot) described in section [Data Visualization Functions] of [Appendix A](#appndx_a).
:::

\newpage

#### UMGYDE Model Regularization: *Fine-tuning*
\

::: {.noteblock data-latex=""}
The complete version of the source code shown in this section can be found in the [UMGYDE Model Regularization: Fine-tuning](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2109) section of the [capstone-movielens.main.R](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2109) script on _GitHub_.
:::

We are now ready to perform the fine-tuning step of our model _regularization_ process to determine the best value for the $\lambda$ parameter.

The following [piece of code](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2110) prepares the interval of values for the $\lambda$ parameter, over which the operation has to be done:
```{r main-script@l2110, eval=FALSE}
endpoints <- 
  get_fine_tune.param.endpoints(cv.UMGYDE.preset.result$tuned.result)

UMGYDE.loop_starter <- c(endpoints["start"], 
                        endpoints["end"], 
                        8)
```

::: {.noteblock data-latex=""}
The helper function [get_fine_tune.param.endpoints](#func.get_fine_tune.param.endpoints) used in code snippet above is described in the sections [Model Tuning Utils](#appndx_a.CHF.model_tuning_utils) of [Appendix A](#appndx_a).
:::

```{r, echo=FALSE}
writeLines("*** Values of the endpoints and the divisor for the interval of `lambda` values ***")
```
```{r}
UMGYDE.loop_starter
```

And the next [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2120) below accomplishes the task of *fine-tuning* the model:
```{r main-script@l2120, eval=FALSE}
cache.base_name <- "UMGYDE.rglr.fine-tuning"

UMGYDE.rglr.fine_tune.results <- 
  model.tune.param_range(UMGYDE.loop_starter,
                         UMGYDE.rglr.fine_tune.cache.path,
                         cache.base_name,
                         regularize.test_lambda.UMGYD_effect.cv)

UMGYDE.rglr.fine_tune.RMSE.best <- UMGYDE.rglr.fine_tune.results$best_result["best_RMSE"]
```

::: {.noteblock data-latex=""}
The custom functions [model.tune.param_range](#func.model.tune.param_range) and [regularize.test_lambda.UMGYD_effect.cv](#func.regularize.test_lambda.UMGYD_effect.cv) used in the code snippet above are described in the sections [Model Tuning Utils](#appndx_a.CHF.model_tuning_utils) and  [UMGYDE Model: Regularization], respectively, of [Appendix A](#appndx_a).
:::

\newpage

Below are the results of fine-tuning the *UMGYDE Model*:

```{r, echo=FALSE}
writeLines("*** Path to the cache directory for intermediate fine-tuning results ***")
```
```{r}
UMGYDE.rglr.fine_tune.cache.path
```
```{r, echo=FALSE}
writeLines("*** Fine-tuning results object data structure ***")
```
```{r}
str(UMGYDE.rglr.fine_tune.results)
```
```{r, echo=FALSE}
writeLines("*** Fine-tuning: best results ***")
```
```{r}
UMGYDE.rglr.fine_tune.results$best_result
UMGYDE.rglr.fine_tune.RMSE.best
```

\newpage

The following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2135) provides a visual representation of the *fine-tuning results* we have just computed:
```{r main-script@l2135}
UMGYDE.rglr.fine_tune.results$tuned.result |>
  data.plot(title = "UMGYDE Model Regularization: Fine-tuned result",
              xname = "parameter.value",
              yname = "RMSE",
              xlabel = TeX(r'[$\lambda$]'),
              ylabel = str_glue("Deviation from the best RMSE value (",
                                as.character(round(UMGYDE.rglr.fine_tune.RMSE.best, digits = 7)),
                                ")"),
              normalize = TRUE)
```

::: {.noteblock data-latex=""}
Note that in the code snippet above, we use the custom data visualization function [data.plot](#func.data.plot) (described in section [Data Visualization Functions] of [Appendix A](#appndx_a)) with the argument [normalize](#func.data.plot.args.normalize) set to `TRUE`, which means that deviations from the minimum $y$ value are used to plot, rather than the $y$ values themselves.
:::

\newpage

#### UMGYDE Model Regularization: *Retraining on the `edx` with the best* $\lambda$
\

::: {.noteblock data-latex=""}
The complete version of the source code shown in this section is available in the [UMGYDE Model Regularization: Retraining with the best params](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2148) section of the [capstone-movielens.main.R](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2148) script on _GitHub_.
:::

Now, we can refine the *UMGYDE Model* by retraining on the entire `edx` dataset with the best value of the $\lambda$ parameter we just figured out (let's call it *Regularized UMGYDE Model*), for the definitive *RMSE* calculation and use in subsequent models:

The following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2161) performs this operation:
```{r main-script@l2161, eval=FALSE}
best_result <- UMGYDE.rglr.fine_tune.results$best_result
UMGYDE.rglr.best_lambda <- best_result["param.best_value"]

put_log1("Re-training Regularized User+Movie+Genre+Year+(Smoothed)Day Effect Model for the best `lambda`: %1...",
         UMGYDE.rglr.best_lambda)

rglr.UMGYD_effect <- edx |> 
  regularize.train_UMGYD_effect(UMGYDE.rglr.best_lambda)
```

::: {.noteblock data-latex=""}
In the code snippet above we use the [regularize.train_UMGYD_effect](#func.regularize.train_UMGYD_effect) function described in section [UMGYDE Model: Regularization] of [Appendix A](#appndx_a).
:::

```{r, echo=FALSE}
writeLines("*** The Best UMGYD Effect Fine-tuning Results ***")
```
```{r}
UMGYDE.rglr.fine_tune.results$best_result
```

```{r, echo=FALSE}
writeLines("*** Regularized UMGYD Effect Structure ***")
```
```{r}
  str(rglr.UMGYD_effect)

print_log1("Regularized UMGYDE Model has been re-trained for the best `lambda`: %1.",
         UMGYDE.rglr.best_lambda)
```

\newpage

Now, we are ready to construct predictors and calculate the *RMSE* score for the ultimately *Regularized UMGYE Model* using the following [line of code](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2172): 
```{r main-script@l2172, eval=FALSE}
  rglr.UMGYD_effect.RMSE <- calc_UMGY_SmoothedDay_effect.RMSE.cv(rglr.UMGYD_effect)
```

::: {.noteblock data-latex=""}
In the code snippets above, we use the [calc_UMGY_SmoothedDay_effect.RMSE.cv](#func.calc_UMGY_SmoothedDay_effect.RMSE.cv) user-defined described in section [UMGYDE Model: Utility Functions] of [Appendix A](#appndx_a).
:::

Finally, we add the definitive *RMSE* value obtained above to our *Result Table* and print the table using the following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2218):
```{r main-script@l2218, eval=FALSE}
RMSEs.ResultTibble.UMGYDE.rglr.tuned <- RMSEs.ResultTibble.UMGYDE.tuned |> 
  RMSEs.AddRow("Regularized UMGYDE Model", 
               rglr.UMGYD_effect.RMSE,
               comment = "The best tuned and regularized UMGYDE Model.")
```
```{r}
RMSE_kable(RMSEs.ResultTibble.UMGYDE.rglr.tuned)
```

::: {.noteblock data-latex=""}
In the code snippet above, we use the [RMSEs.AddRow](#func.RMSEs.AddRow) and [RMSE_kable](#func.RMSE_kable) functions described in section [Result RMSEs Tibble Functions] of [Appendix A](#appndx_a).
:::

Now, we have a better result than the ones for the previous models, but still insufficient to meet the Project Objective. Let's see what else we can do to achieve our ultimate goal.

As explained in [Section 33.11 `Matrix Factorization`](https://rafalab.dfci.harvard.edu/dsbook/large-datasets.html#matrix-factorization) of the *Course Textbook (First Edition)*, so far our models ignore _"an important source of variation related to the fact that groups of movies have similar rating patterns and groups of users have similar rating patterns as well..."_ [@IDS_E1_33-11]

The author shows that in this case, the *Matrix Factorization* method can significantly improve our results. In the next section, we will apply this method to our latest model and see what results we achieve.

\newpage
