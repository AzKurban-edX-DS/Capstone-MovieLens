---
title: "func_tmp"
output: html_document
---



#### [loess_de](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/support-functions/UMGYD-effect.functions.R#L71) Function {#func.loess_de}
\

Using local fitting, fits a polynomial surface determined by the *Day General Effect* (hereafter *DG Effect* or *DGE* for short) data passed in the [de_bias.dat](#func.loess_de.args.de_bias.dat) argument.

::: {.noteblock data-latex=""}
In *this Project*, the *DGE* data object to be passed in the [de_bias.dat](#func.loess_de.args.de_bias.dat) argument is returned by the [calc_day_general_effect](#func.calc_day_general_effect) and [calc_day_general_effect.cv](#func.calc_day_general_effect.cv) functions (both described above).
:::

::: { #func.loess_de.usage .sidebar }
##### Usage
\

```{r UMGYD_effect.func@l87, eval=FALSE}
  fit <- day_gen_effect |> loess_de(degree, span)
```

::: {.noteblock data-latex=""}
In the [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/support-functions/UMGYD-effect.functions.R#L87) above, the function described here is called within the [calc_UMGY_SmoothedDay_effect](#func.calc_UMGY_SmoothedDay_effect) custom helper function (described below in *this Section*).
:::
:::

::: { #func.loess_de.args .sidebar }
##### Arguments
\

::: { #func.loess_de.args.de_bias.dat .sidebar }
###### ***de_bias.dat***
\

Data frame object representing the *Day General Effect*. 
:::

::: { #func.loess_de.args.degree .sidebar }
###### ***degree***
\

(Optional, *Integer*, `NA` by default) The degree of the polynomials to pass in the same-named argument to the internally called [stats::loess](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/loess) function.

::: {.noteblock data-latex=""}
When the value is `NA` (the default), the [stats::loess](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/loess) is called with `degree = 1`. 
:::
:::

::: { #func.loess_de.args.span .sidebar }
###### ***span***
\

(Optional, *Numeric*, `NA` by default ) The parameter $\alpha$ (which controls the degree of smoothing) to pass in the same-named argument to the internally called [stats::loess](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/loess).

::: {.noteblock data-latex=""}
When the value is `NA` (the default), the [stats::loess](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/loess) is called with `span = 0.75`. 
:::
:::
:::

::: { #func.loess_de.details .sidebar }
##### Details
\

This function is a wrapper for the [stats::loess](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/loess) `R` function, which is called internally to make a necessary fit.

::: {.noteblock data-latex=""}
This is an auxiliary function intended for use in other custom helper functions, such as the [calc_UMGY_SmoothedDay_effect](#func.calc_UMGY_SmoothedDay_effect) (described below in *this Section*) as shown above in the [Usage](#func.loess_de.usage) section of *this Description*.
:::
:::

::: { #func.loess_de.value .sidebar }
##### Value
\

Object of class `loess` returned by the internally called [stats::loess](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/loess).
:::

::: { #func.loess_de.code .sidebar }
##### Source Code
\

The source code of the [loess_de](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/support-functions/UMGYD-effect.functions.R#L71) function is shown below:
```{r eval=FALSE}
loess_de <- function(de_bias.dat, degree = NA, span = NA){
  if(is.na(degree)) degree = 1
  if(is.na(span)) span = 0.75
  loess(de ~ days, span = span, degree = degree, data = de_bias.dat)
}
```

::: {.noteblock data-latex=""}
The source code of the [loess_de](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/support-functions/UMGYD-effect.functions.R#L71) function is also available in the [Utility Functions](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/support-functions/UMGYD-effect.functions.R#L3) section of the [UMGYD-effect.functions.R](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/support-functions/UMGYD-effect.functions.R#L71) script on _GitHub_.
:::
:::

\newpage


#### [model.tune.param_range](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/support-functions/common-helper.functions.R#L208) Function {#func.model.tune.param_range}
\

Implements an algorithm for fine-tuning the model under test by figuring out the most precise value possible of the *tuning parameter* over a given interval determined by the $start$ and $end$ values of the interval passed in the [loop_starter](#func.model.tune.param_range.args.loop_starter) argument.

##### Signature
\
```{r eval=FALSE}
model.tune.param_range <- function(loop_starter,
                             tune_dir_path,
                             cache_file_base_name,
                             fn_tune.test.param_value,
                             max.identical.min_RMSE.count = 4,
                             endpoint.min_diff = 0,
                             break.if_min = TRUE,
                             steps.beyond_min = 2){
  # ...
  list(best_result = param_values.best_result,
       param_values.endpoints = c(prm_val.leftmost, prm_val.rightmost, seq_increment),
       tuned.result = data.frame(parameter.value = parameter.value,
                                 RMSE = result.RMSE))
}
```

::: { #func.model.tune.param_range.args .sidebar }
##### Arguments
\

::: { #func.model.tune.param_range.args.loop_starter .sidebar }
###### ***loop_starter***
\
A numeric vector of the form `c(start, end, dvs)`, where `start` and `end` are the endpoints of the interval over which the value of the *tuning parameter* that minimizes *RMSE* has to be found.

The `dvs` is a divisor used to calculate the *step size* for partitioning the interval into a sequence of parameter values, among which the value that minimizes *RMSE* has to be found.

So the *step size* of the sequence is calculated as follows:
$$
step = \frac{end - start}{dvs}
$$  

The sequence obtained as a result of the transformation is equivalent to the one generated by the function [base::seq](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/seq) as follows:
```{r eval=FALSE}
seq(start, end, step)
```  

::: {.noteblock data-latex=""}
In the function body, the *step size* is stored in the local variable `seq_increment`, and the values of $start$, $end$, and $dvs$ are stored in the local variables `seq_start`, `seq_end`, and `interval_divisor`, respectively.
:::

In fact, the [seq](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/seq) function is called internally to generate the sequence during the algorithm's execution by the following [line of code](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/support-functions/common-helper.functions.R#L256):
```{r eval=FALSE}
    test_param_vals <- seq(seq_start, seq_end, seq_increment)
```
:::

::: { #func.model.tune.param_range.args.tune_dir_path .sidebar }
###### ***tune_dir_path***
\

To improve performance, the algorithm caches intermediate results in the file system. The value passed in *this argument* specifies the path to the directory where the files are cached.
:::

::: { #func.model.tune.param_range.args.cache_file_base_name .sidebar }
###### ***cache_file_base_name***
\

The algorithm generates unique names for cache files based on this and the [loop_starter](#func.model.tune.param_range.args.loop_starter) arguments' values, as well as a few other intermediate values calculated at runtime.
:::

::: { #func.model.tune.param_range.args.fn_tune.test.param_value .sidebar }
###### ***fn_tune.test.param_value***
\

Name of a model-specific helper function to pass to the [same-named argument](#func.tune.model_param.args.fn_tune.test.param_value) of the [tune.model_param](#func.tune.model_param) function (see description above) that is called internally during the execution of the algorithm.
:::

::: { #func.model.tune.param_range.args.max.identical.min_RMSE.count .sidebar }
###### ***max.identical.min_RMSE.count***
\
(Optional, 4 by default) If more than one identical minimum *RMSE* value is calculated during execution, the number of identical minimums is limited by the value of *this argument*. When it is reached, the algorithm considers the task execution to be complete.
:::

::: { #func.model.tune.param_range.args.endpoint.min_diff .sidebar }
###### ***endpoint.min_diff***
\
(Optional, 0 by default) Defines the sensitivity threshold for determining the neighborhood boundaries of the minimum `RMSE` value (see the [Details](#func.model.tune.param_range.details) section below for more details).
:::

::: { #func.model.tune.param_range.args.break.if_min .sidebar }
###### ***break.if_min***
\
(Optional, `TRUE` by default) Boolean value to pass to the [same-named argument](#func.tune.model_param.args.break.if_min) of the [tune.model_param](#func.tune.model_param) function (see description above) that is called internally during the execution of the algorithm.
:::

::: { #func.model.tune.param_range.args.steps.beyond_min .sidebar }
###### ***steps.beyond_min***
\
(Optional, 2 by default) Numeric value to pass to the [same-named argument](#func.tune.model_param.args.steps.beyond_min) of the [tune.model_param](#func.tune.model_param) function (see description above) that is called internally during the execution of the algorithm.
:::
:::

\newpage

::: { #func.model.tune.param_range.details .sidebar }
##### **Details** 
\

With the approach used in this algorithm, the best value of the *tuning parameter* (we call this the *best value of the tuning parameter*) is considered to be the value corresponding to the minimum value of the *Root Mean Square Error (RMSE)* for the model being tested.

During the execution, the algorithm organizes a cycle consisting of the following steps:

::: { #func.model.tune.param_range.details.step1 .sidebar }
  1. Calculates the step size for partitioning the interval into a sequence of values and save it to the local variable `seq_increment` as described in the [loop_starter](#func.model.tune.param_range.args.loop_starter) argument description above using the following [line of code](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/support-functions/common-helper.functions.R#L240):
```{r eval=FALSE}
    seq_increment <- (seq_end - seq_start)/interval_divisor 
```

:::

::: { #func.model.tune.param_range.details.step2 .sidebar }
  2. Checks if the *step size* of the generated sequence is less than the minimum allowed value (in the current implementation, we use `1e-13`), and if so, exits the loop and goes to the [Finalizing Execution](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/support-functions/common-helper.functions.R#L426) section of the code described in the [Finalizing Execution](#func.model.tune.param_range.details.finalizing) subsection below. 
  
  - Otherwise, proceeds to the [next step](#func.model.tune.param_range.details.step3):  
```{r eval=FALSE}
    if (seq_increment < 0.0000000000001) {
      warning("Function `model.tune.param_range`:
parameter value increment is too small.")
      
      put_log2("Function `model.tune.param_range`:
Final best RMSE for `parameter value = %1`: %2",
               param_values.best_result["param.best_value"],
               param_values.best_result["best_RMSE"])
      
      put(param_values.best_result)
      # browser()
      break
    }
```

:::

::: {.noteblock data-latex=""}
In the code snippet above, we use the custom function [put_log2](#func.put_log2) described above in the [Logging Functions] section of *this Appendix*.
:::  

::: { #func.model.tune.param_range.details.step3 .sidebar }
  3. If the *step size* is no less than the minimum allowed value (`seq_increment >= 1e-13` in our case), creates a vector containing a sequence of parameter values (as described in the [loop_starter](#func.model.tune.param_range.args.loop_starter) argument description above) using the following [line of code](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/support-functions/common-helper.functions.R#L256):
```{r eval=FALSE}
    test_param_vals <- seq(seq_start, seq_end, seq_increment)
```

:::

::: { #func.model.tune.param_range.details.step4 .sidebar }
  4. Generates a unique name for the current iteration's cache file based on the values passed in the [cache_file_base_name](#func.model.tune.param_range.args.cache_file_base_name) and [loop_starter](#func.model.tune.param_range.args.loop_starter) arguments, along with the values stored in the local variables `seq_start`, `seq_end`, and `interval_divisor`, concatenates the name with the path passed in the [tune_dir_path](#func.model.tune.param_range.args.tune_dir_path) argument, and stores the value in the local variable `file_path_tmp`:  
```{r eval=FALSE}
    file_name_tmp <- cache_file_base_name |>
      str_c("_") |>
      str_c(as.character(loop_starter[1])) |>
      str_c("_") |>
      str_c(as.character(loop_starter[3])) |>
      str_c("_") |>
      str_c(as.character(interval_divisor)) |>
      str_c(".") |>
      str_c(as.character(seq_start)) |>
      str_c("-") |>
      str_c(as.character(seq_end)) |>
      str_c(".RData")
    
    file_path_tmp <- file.path(tune_dir_path, file_name_tmp)
    
    put_log1("Function `model.tune.param_range`:
File path generated: %1", file_path_tmp)
```

::: {.noteblock data-latex=""}
In the code snippet above, we use the custom function [put_log1](#func.put_log1) described above in the [Logging Functions] section of *this Appendix*.
:::
:::

  5. Checks whether a file with the full name stored in the `file_path_tmp` variable exists, and if so, loads all the necessary information for the current iteration from it and goes to [step 8](#func.model.tune.param_range.details.step8). Otherwise, proceeds to the [next step](#func.model.tune.param_range.details.step6):
```{r eval=FALSE}
    if (file.exists(file_path_tmp)) {
      put_log1("Function `model.tune.param_range`:
Loading tuning data from file: %1...", file_path_tmp)
      
      load(file_path_tmp)
      put_log1("Function `model.tune.param_range`:
Tuning data has been loaded from file: %1", file_path_tmp)
      
      tuned.result <- tuned_result$tuned.result
    } else {
      # ...
    }
```


::: { #func.model.tune.param_range.details.step6 .sidebar }
  6. Calls the helper function [tune.model_param](#func.tune.model_param) and stores the returned result in the local variable `tuned_result`, passing the vector created earlier in [step 3](#func.model.tune.param_range.details.step3) to the argument [param_values](#func.tune.model_param.args.param_values) along with the values of the remaining arguments passed in the following arguments of the same name to *this function*:
    - [fn_tune.test.param_value](#func.model.tune.param_range.args.fn_tune.test.param_value);
    - [break.if_min](#func.model.tune.param_range.args.break.if_min);
    - [steps.beyond_min](#func.model.tune.param_range.args.steps.beyond_min):
```{r eval=FALSE}
      tuned_result <- tune.model_param(test_param_vals, 
                                        fn_tune.test.param_value,
                                        break.if_min,
                                        steps.beyond_min)
```

:::

::: { #func.model.tune.param_range.details.step7 .sidebar }
  7. Extracts the data frame element stored in the variable `tuned_result$tuned.result` from the *list object* saved in the local variable `tuned_result` in the [previous step](#func.model.tune.param_range.details.step6) and stores it in the local variable `tuned.result`. Then stores the variable `tuned_result` along with the necessary auxiliary information in the cache file with the full name created earlier in [step 4](#func.model.tune.param_range.details.step4):
```{r eval=FALSE}
      tuned.result <- tuned_result$tuned.result
      
      save(tuned_result,
           param.best_value,
           seq_increment,
           interval_divisor,
           file = file_path_tmp)

      put_log1("Function `model.tune.param_range`:
File saved: %1", file_path_tmp)
```
:::



::: { #func.model.tune.param_range.details.step8 .sidebar }
  8. Determines endpoints for a new interval of the *tuning parameter* values in the neighborhood of the minimum *RMSE* value (figured out so far)  with use of the helper function [get_fine_tune.param.endpoints.idx](#func.get_fine_tune.param.endpoints.idx) described above, to improve the accuracy of the *RMSE* calculation in the next iteration:
```{r eval=FALSE}
    bound.idx <- get_fine_tune.param.endpoints.idx(tuned.result)
    start.idx <- bound.idx["start"]
    end.idx <- bound.idx["end"]

    prm_val.leftmost.tmp <- tuned.result$parameter.value[start.idx]
    RMSE.leftmost.tmp <- tuned.result$RMSE[start.idx]

    prm_val.rightmost.tmp <- tuned.result$parameter.value[end.idx]
    RMSE.rightmost.tmp <- tuned.result$RMSE[end.idx]
    
    min_RMSE <- tuned.result$RMSE[best_RMSE.idx]
    min_RMSE.prm_val <- tuned.result$parameter.value[best_RMSE.idx]

    seq_start <- prm_val.leftmost.tmp
    seq_end <- prm_val.rightmost.tmp
```

:::

::: { #func.model.tune.param_range.details.step9 .sidebar }
  9. Checks whether the local variable `best_RMSE` is already initialized, and if not, initializes it to the minimum *RMSE* value for the current iteration, figured out in the [previous step](#func.model.tune.param_range.details.step8), along with local variables intended to store the endpoint values:
```{r eval=FALSE}
    if (is.na(best_RMSE)) {
      prm_val.leftmost <- prm_val.leftmost.tmp
      RMSE.leftmost <- RMSE.leftmost.tmp
      
      prm_val.rightmost <- prm_val.rightmost.tmp
      RMSE.rightmost <- RMSE.rightmost.tmp
      
      param.best_value <- min_RMSE.prm_val
      best_RMSE <- min_RMSE
    }
```

:::


::: { #func.model.tune.param_range.details.step10 .sidebar }
  10. Checks the deviations from the minimum *RMSE* value for the values corresponding to the endpoints of the new interval of the *tuning parameter* values figured out in the [step 8](#func.model.tune.param_range.details.step8), and updates in corresponding local variables those parameter endpoint and correspondinng *RMSE* values, for which the corresponding deviation reaches the minimum threshold specified by the value passed in the [endpoint.min_diff](#func.model.tune.param_range.args.endpoint.min_diff) argument:  
```{r eval=FALSE}
    if (RMSE.leftmost.tmp - min_RMSE >= endpoint.min_diff) {
      prm_val.leftmost <- prm_val.leftmost.tmp
      RMSE.leftmost <- RMSE.leftmost.tmp
    } 
    
    if (RMSE.rightmost.tmp - min_RMSE >= endpoint.min_diff) {
      prm_val.rightmost <- prm_val.rightmost.tmp
      RMSE.rightmost <- RMSE.rightmost.tmp
    } 
```

:::


::: { #func.model.tune.param_range.details.step11 .sidebar }
  11. Makes sure that the index of the start endpoint of the parameter interval figured out in the [step8](#func.model.tune.param_range.details.step8) is less than the index of the end endpoint and, if not, exits the loop with the *warning message* and goes to the [Finalizing Execution](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/support-functions/common-helper.functions.R#L426) section of the code described in the [Finalizing Execution](#func.model.tune.param_range.details.finalizing) subsection below: 
```{r eval=FALSE}
    if (end.idx - start.idx <= 0) {
      warning("`tuned.result$parameter.value` sequential start index are the same or greater than end one.")
      put_log1("Function `model.tune.param_range`:
Current minimal RMSE: %1", rmse_min)
      
      put_log2("Function `model.tune.param_range`:
Reached minimal RMSE for the test parameter value = %1: %2",
               param_values.best_result["param.best_value"],
               param_values.best_result["best_RMSE"])
      
      put(param_values.best_result)
      break
    }
```
:::

::: { #func.model.tune.param_range.details.step11 .sidebar }
  12. Checks if the minimum *RMSE* value determined so far (and stored in the local variable `best_RMSE`) is equal to the minimum *RMSE* value calculated for the current iteration (stored in the `min_RMSE`), and if so, outputs an appropriate warning message and proceeds to the [next step](#func.model.tune.param_range.details.step13). 
  
  - Otherwise, makes sure that the minimum *RMSE* value determined so far is no less than the minimum *RMSE* value calculated for the current iteration (`best_RMSE >= min_RMSE`) and goes to [step ?](#).
  
  - Otherwise, **stops execution** with the error message (considers a fatal error!):
```{r eval=FALSE}
    if (best_RMSE == min_RMSE) {
      warning("Currently computed minimal RMSE equals the previously reached best one: ",
              best_RMSE, "
Currently computed minial value is: ", min_RMSE)
      
      put_log2("Function `model.tune.param_range`:
Current minimal RMSE for `parameter value = %1`: %2",
               tuned.result$parameter.value[which.min(tuned.result$RMSE)],
               min_RMSE)
      
      put_log2("Function `model.tune.param_range`:
So far reached best RMSE for `parameter value = %1`: %2",
               param_values.best_result["param.best_value"],
               param_values.best_result["best_RMSE"])
      
      put(param_values.best_result)
      
      # goes to the next step of the current iteration
      # ...
      
    } else if (best_RMSE < min_RMSE) {
      warning("Current minimal RMSE is greater than previously computed best value: ",
              best_RMSE, "
Currently computed minial value is: ", min_RMSE)
      stop("Current minimal RMSE is greater than previously computed best value: ",
           best_RMSE, "
Currently computed minial value is: ", min_RMSE)
    }
```
:::

::: { #func.model.tune.param_range.details.step13 .sidebar }
  13. (`best_RMSE == min_RMSE`) Checks the number of matches between the minimum *RMSE* value determined so far and the minimum *RMSE* value calculated for the current iteration (`best_RMSE == min_RMSE`), and if it exceeds the value passed in the argument [max.identical.min_RMSE.count](#func.model.tune.param_range.args.max.identical.min_RMSE.count), saves the best results for the *tuning parameter* and corresponding *RMSE* values figured out in the current iteration in the local variable `param_values.best_result` and exits the loop with an appropriate warning message and goes to the [Finalizing Execution](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/support-functions/common-helper.functions.R#L426) section of the code described in the [Finalizing Execution](#func.model.tune.param_range.details.finalizing) subsection below. 
  
  - Otherwise, proceeds to the [next step](#func.model.tune.param_range.details.step14):
```{r eval=FALSE}
    if (best_RMSE == min_RMSE) {
      
      # Outputs an appropriate warning message
      # ...
      
      if (sum(tuned.result$RMSE[tuned.result$RMSE == min_RMSE]) >= max.identical.min_RMSE.count) {
        warning("Minimal `RMSE`identical values count reached it maximum allowed value: ",
                max.identical.min_RMSE.count)

        put(tuned.result$RMSE)
        
        param_values.best_result <-
          get_best_param.result(tuned.result$parameter.value,
                                tuned.result$RMSE)

        put_log2("Function `model.tune.param_range`:
      Reached the best RMSE for `parameter value = %1`: %2",
                 param_values.best_result["param.best_value"],
                 param_values.best_result["best_RMSE"])
        break
      }
    } else if (best_RMSE < min_RMSE) {
      # Fatal Error! (stops the execution)
    }
```

::: {.noteblock data-latex=""}
To retrieve the best results for the current iteration from the data stored in the local variable `tuned.result`, the helper function [get_best_param.result](#func.get_best_param.result) described above is used.
:::
:::

::: { #func.model.tune.param_range.details.step14 .sidebar }
  14. Updates the following local variables: `best_RMSE` (wihich stores the current best *RMSE* value) with the minimum *RMSE* value computed for the current iteration (stored in the `min_RMSE`) and `param_values.best_result` with the best results retrieved from the  `tuned.result`, and proceeds to the next iteration from the [step 1](#func.model.tune.param_range.details.step1):
  
```{r eval=FALSE}
    # ...
    
    best_RMSE <- min_RMSE
    param.best_value <- min_RMSE.prm_val

    param_values.best_result <- 
      get_best_param.result(tuned.result$parameter.value, 
                          tuned.result$RMSE)
    
    put_log2("Function `model.tune.param_range`:
Currently reached best RMSE for `parameter value = %1`: %2",
             param_values.best_result["param.best_value"],
             param_values.best_result["best_RMSE"])
    
    put(param_values.best_result)
  }
  # End repeat loop
```
:::

::: { #func.model.tune.param_range.details.finalizing .sidebar }
###### ***Finalizing Execution***
\

Finally, the algorithm initializes the objects to be included in the return list with the results obtained during execution and returns the *list object* to the client code:
```{r eval=FALSE}
  # Finalizing execution:
  n <- length(tuned.result$parameter.value)
  
  parameter.value <- tuned.result$parameter.value
  result.RMSE <- tuned.result$RMSE
  
  if (result.RMSE[1] == best_RMSE) {
    parameter.value[1] <- prm_val.leftmost
    result.RMSE[1] <- RMSE.leftmost
  }
  
  if (result.RMSE[n] == best_RMSE) {
    parameter.value[n+1] <- prm_val.rightmost
    result.RMSE[n+1] <- RMSE.rightmost
  }
  
  list(best_result = param_values.best_result,
       param_values.endpoints = c(prm_val.leftmost, prm_val.rightmost, seq_increment),
       tuned.result = data.frame(parameter.value = parameter.value,
                                 RMSE = result.RMSE))
```
:::

::: {#func.model.tune.param_range.value .sidebar }
##### **Value**
\

This function returns a list of three objects:
```{r eval=FALSE}
  list(best_result = param_values.best_result,
       param_values.endpoints = c(prm_val.leftmost, prm_val.rightmost, seq_increment),
       tuned.result = data.frame(parameter.value = parameter.value,
                                 RMSE = result.RMSE))
```

The objects comprising the return list are as follows:

  - `best_result`: A vector containing a *pair of values*: the found *best value of the tuning parameter* for which the *RMSE* value is minimal, along with the minimal *RMSE* value itself;

  - `param_values.endpoints`: Information related to the final interval of the *tuning parameter* values;

  - `tuned.result`: A data frame containing two variables:
  
    - *parameter.value*: A vector containing all processed values of the *tuning parameter*;
    
    - *RMSE*: A vector containing the *RMSE* values corresponding to the processed *tuning parameter* values.

:::

::: {#func.model.tune.param_range.code .sidebar }
##### Source Code
\

The complete source code of the function [model.tune.param_range](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/support-functions/common-helper.functions.R#L208) is available in the [Regularization](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/support-functions/common-helper.functions.R#L69) section of the [common-helper.functions.R](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/support-functions/common-helper.functions.R#L208) script on _GitHub_.
:::

\newpage

#### [UMGYDE_model.predict](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/support-functions/MF.functions.R#L14) Function {#func.UMGYDE_model.predict}
\


::: { #func.UMGYDE_model.predict.usage .sidebar }
##### Usage
\

```{r eval=FALSE}

```
:::

::: { #func.UMGYDE_model.predict.args .sidebar }
##### Arguments
\

::: { #func.UMGYDE_model.predict.args.file_name .sidebar }
  - **test_set:** ; 

:::
:::

::: { #func.UMGYDE_model.predict.details .sidebar }
##### Details
\


:::

::: { #func.UMGYDE_model.predict.value .sidebar }
##### Value
\


:::

::: { #func.UMGYDE_model.predict.code .sidebar }
##### Source Code
\

The source code of the [UMGYDE_model.predict](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/support-functions/MF.functions.R#L14) function is shown below:
```{r eval=FALSE}
UMGYDE_model.predict <- function(test_set) {
  test_set |>
    UMGY_SmoothedDay_effect.predict(rglr.UMGYD_effect)
}
```

::: {.noteblock data-latex=""}
The source code of the [UMGYDE_model.predict](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/support-functions/MF.functions.R#L14) function is defined in the [MF.functions.R](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/support-functions/MF.functions.R#L14) script on _GitHub_.
:::
:::




