## UMGYDE Model: Matrix Factorization (MF)
\

For our next solution, we will use the [`recosystem` package](https://cran.r-project.org/web/packages/recosystem/index.html) to perform the _Parallel Matrix Factorization_.

### MF: Matematical Description
\

As outlined in [this article](https://cran.r-project.org/web/packages/recosystem/vignettes/introduction.html)[@yqiu_recosystem230505], the idea of the _Matrix Factorization_ method is to approximate the whole rating matrix $R_{m \times n}$ by the product of two matrices of lower dimensions, $P_{n \times k}$ and $Q_{n\times k}$, such that 

\begin{equation}
\mathbb{R} \approx \mathbb{PQ^T}
(\#eq:R-PQ-MF)
\end{equation}

In relation to our model, the expression \@ref(eq:R-PQ-MF) will take the form:

\begin{equation}
\mathbf{R} \thicksim \mathbf{\hat{R}} + \mathbf{PQ^T} +  \varepsilon
(\#eq:UMGYDE-MF)
\end{equation}


where:
  
  - $\mathbf{R}$ is the $U_\mathrm{m} \times M_n$ rating matrix with $U_m$ users and $M_n$ movies;
  - $\mathbf{\hat{R}}$ represents the predictions from our best model: _Regularized UMGYDE Model_;
  - $\mathbf{P}$ and $\mathbf{Q}$ are $P_{m \times k}$ and $Q_{n \times k}$ matrices, respectively, where $k$ is the number of _latent features_ to be found.

If we denote the $u$-th row of $\mathbf{P}$ as $\mathbf{p}_u$ and the $v$-th row of $\mathbf{Q}$ as $\mathbf{q}_v$, then the unknown rating $\mathbf{r}_{u,v}$ given by user $u$ on movie item $v$ for our model can be estimated as $\hat{\mathbf{r}}_{u,v} + \mathbf{p}_{u}\mathbf{q}^T_{v}$, where the $\hat{\mathbf{r}}_{u,v}$ is the prediction given by our last _Regularized UMGYDE Model_.

A typical solution for $\mathbf{P}$ and $\mathbf{Q}$ is given by the following optimization problem [@chin_FPSGM_MF_SMS2015a; @chin_LRS_SGM_MF2015b]:

$$
\begin{array}{c} {\scriptscriptstyle min} \\
{\scriptscriptstyle P,Q} \end{array} \sum_{(u,v)\in R}[f(\mathbf{p}_u, \mathbf{q}_v; \mathbf{r}_{u,v}) + \mu_P\parallel\mathbf{p}_u\parallel_1 + \mu_Q\parallel\mathbf{q}_v\parallel_1 + \frac{\lambda_P}2\parallel\mathbf{p}_u\parallel^2_2 + \frac{\lambda_Q}2\parallel\mathbf{q}_v\parallel^2_2]
$$

where $(u, v)$ are locations of observed entries in $\mathbf{R}, \mathbf{r}_{u,v}$ is the observed ratings, $f$ is the loss function, and $\mu_P$, $\mu_Q$, $\lambda_P$, $\lambda_Q$ are penalty parameters to avoid overfitting.[@yqiu_recosystem230505]

::: { custom-style="blockquote" } 
> _The process of solving the matrices $P$ and $Q$ is referred to as model training, and the selection of penalty parameters is called parameter tuning. In `recosystem`, we provide convenient functions for these two tasks, and additionally have functions for model exporting (outputting $P$ and $Q$ matrices) and prediction._[@yqiu_recosystem230505]

:::

\newpage

### MF: Helper Functions

#### [mf.residual.dataframe](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/support-functions/MF.functions.R#L1) Function {#func.mf.residual.dataframe}
\

::: { #func.mf.residual.dataframe.params.description .sidebar }
##### Description
\

Computes residuals, defined as the difference between the observed and predicted values of the fully trained _UMGYDE Model_ as described in the [User+Movie+Genre+Year+Day Effect (UMGYDE) Model] section.

##### Parameters
\

###### ***train_set***
\

::: { #func.mf.residual.dataframe.params.train_set .sidebar }
The dataset to be trained.
:::

##### Source Code
\

The folowing is the source code of the function:
```{r eval=FALSE}
mf.residual.dataframe <- function(train_set){
  train_set |> 
    left_join(edx.user_effect, by = "userId") |>
    left_join(rglr.UM_effect, by = "movieId") |>
    left_join(rglr.UMG_effect, by = "movieId") |>
    left_join(date_days_map, by = "timestamp") |>
    left_join(rglr.UMGY_effect, by='year') |>
    left_join(rglr.UMGYD_effect, by='days') |>
    mutate(rsdl = rating - (mu + a + b + g + ye + de_smoothed)) |>
    select(userId, movieId, rsdl)
}
```

::: {.noteblock data-latex=""}
The source code of the [mf.residual.dataframe](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/support-functions/MF.functions.R#L1) function is also available in the [MF.functions.R](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/support-functions/MF.functions.R#L1) script on _GitHub_.
:::

##### Return
\

A data frame object containing the residuals (see the [Description](#func.mf.residual.dataframe.params.description) above for the details). 

\newpage

#### [UMGYDE_model.predict](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/support-functions/MF.functionsR#L12) Function {#func.UMGYDE_model.predict}
\

This is a wrapper for the [UMGY_SmoothedDay_effect.predict](#func.UMGY_SmoothedDay_effect.predict) function described in the [UMGYDE Model: Helper Functions] section above with the fixed [day_smoothed_effect](#func.UMGY_SmoothedDay_effect.predict.params.day_smoothed_effect) parameter value obtained after the _UMGYDE Model_ (described in the [User+Movie+Genre+Year+Day Effect (UMGYDE) Model] section)  has been fully trained.

##### Parameters
\

::: { #func.UMGYDE_model.predict.params.test_set .sidebar }
###### ***test_set***
\

The dataset for testing the _UMGYDE Model_ after it has been fully trained.
:::

##### Source Code
\

The following is the source code of the function:
```{r eval=FALSE}
UMGYDE_model.predict <- function(test_set) {
  test_set |>
    UMGY_SmoothedDay_effect.predict(rglr.UMGYD_effect)
}
```

::: {.noteblock data-latex=""}
The source code of the [UMGYDE_model.predict](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/support-functions/MF.functionsR#L12) function is also available in the [MF.functions.R](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/support-functions/MF.functionsR#L12) script on _GitHub_.
:::

##### Return
\

A data frame object containing predicted values. 

\newpage

### MF: Performing Operation

::: {.noteblock data-latex=""}
The complete source code shown in this section is available in the [Perform the Matrix Factorization & Final Test](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2567) section of the [capstone-movielens.main.R](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2567) script on _GitHub_.
:::

We assume that the _Matrix Factorization_ method is going to be the last one to provide sufficient results, so we will use the entire `edx` dataset as a _Training Set_ and `final_holdout_test` as a _Test Set_ for our final model, skipping the intermediate _train/test_ operations on the split _train/validation_ datasets.

#### MF: Getting Residuals From the UMGYDE Model Prediction Values
\

First, we get residuals from the _UMGYDE Model_ prediction values using the [mf.residual.dataframe](#func.mf.residual.dataframe) function described above:
```{r, eval=FALSE}
  mf.edx.residual <- mf.residual.dataframe(edx)
```
```{r}
  str(mf.edx.residual)
```
#### MF: Transforming Input Data to Be Compatible With the `recosystem` Package
\

Now, let's convert the residuals data and `final_holdout_test` dataset to the input data compatible with the [recosystem](https://cran.r-project.org/web/packages/recosystem/index.html) package to process:
```{r, eval=FALSE}
  set.seed(5430)
  mf.edx.residual.reco <- with(mf.edx.residual, 
                               data_memory(user_index = userId, 
                                           item_index = movieId,
                                           rating = rsdl))

  final_holdout_test.reco <- with(final_holdout_test, 
                          data_memory(user_index = userId, 
                                      item_index = movieId, 
                                      rating = rating))
```
```{r}
str(mf.edx.residual.reco)
str(final_holdout_test.reco)
```

#### MF: Creating and Tuning the `Reco` Object
\

We then create a `reco` object of the `Reco` class and tune it using the `reco$tune` method, passing to it as a `train_data` parameter residual data prepared in the previous step:
```{r, eval=FALSE}
  reco <- Reco()
  
  reco.tuned <- reco$tune(mf.edx.residual.reco, opts = list(dim = c(10, 20, 30),
                                                lrate    = c(0.1, 0.2),
                                                nthread  = 4,
                                                niter    = 10,
                                                verbose  = TRUE))
```
```{r}
str(reco)
str(reco.tuned)
```

#### MF: Final Training
\

Finally, we train the model for the last time using the `reco$train` method, passing to it as a `train_data` parameter the same residual data we used for the tuning:
```{r, eval=FALSE}
  reco$train(mf.edx.residual.reco, opts = c(reco.tuned$min,
                                       niter = 20, 
                                       nthread = 4)) 
```

#### MF: Final Holdout Test
\

From now on, we will work with the `final_holdout_test` dataset for the final testing of our model, obtaining final predictions, and computing the _Root Mean Squared Error_.


First, we get the final predictions combining the predicted residuals from the `reco` objects and predicted values we lastly get from the _UMGYDE Model_ as described in the [UMGYDE Model: Final Holdout Test (Preliminary Assessment)] section:
```{r, eval=FALSE}
  mf.reco.residual <- reco$predict(final_holdout_test.reco, out_memory())

  mf.predicted_ratings <- 
    clamp(final.UMGYDE.predicted$predicted + mf.reco.residual)
```
```{r}
str(mf.reco.residual)
str(mf.predicted_ratings)
```
Next, we compute the _RMSE_ using the [rmse2](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/support-functions/common-helper.functions.R#L28) custom helper function, already mentioned above in the [UMGYDE Model: Final Holdout Test (Preliminary Assessment)] section, and add the result to our _Result Table_:
```{r, eval=FALSE}
final_holdout_test.RMSE <- rmse2(final_holdout_test$rating,
                                     mf.predicted_ratings)
```

::: {.noteblock data-latex=""}
The function [rmse2](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/support-functions/common-helper.functions.R#L28) is defined in the  [(R)MSE-related functions](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/support-functions/common-helper.functions.R#L18) section of the [common-helper.functions.R](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/support-functions/common-helper.functions.R#L28) script on _GitHub_.
:::

And add the result to our _Result Table_:
```{r, eval=FALSE}
final.MF.RMSEs.ResultTibble <- final.RMSEs.ResultTibble.UMGYDE.rglr.tuned |> 
  RMSEs.AddRow("MF (Final Test)", 
               final_holdout_test.RMSE,
               comment = "Matrix Factorization of the Best Model Residuals, Final Holdout Test")
```
```{r}
RMSE_kable(final.MF.RMSEs.ResultTibble)
```

::: {.noteblock data-latex=""}
Finally, we have reached our ultimate goal, since the _Root Mean Squared Error_ we obtained has achieved the required _Project Objective_.
:::


\newpage

