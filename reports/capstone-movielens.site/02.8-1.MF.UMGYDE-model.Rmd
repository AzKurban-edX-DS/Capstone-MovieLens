## UMGYDE Model: Matrix Factorization (MF)
\

::: {.noteblock data-latex=""}
The complete source code shown in this section is available in the [Matrix Factorization (MF)](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2276) section of the [capstone-movielens.main.R](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2276) script on _GitHub_.
:::

For our next solution, we will use the [`recosystem` package](https://cran.r-project.org/web/packages/recosystem/index.html) to perform the _Parallel Matrix Factorization_.

### MF: Matematical Description
\

As outlined in [this article](https://cran.r-project.org/web/packages/recosystem/vignettes/introduction.html)[@yqiu_recosystem230505], the idea of the _Matrix Factorization_ method is to approximate the whole rating matrix $R_{m \times n}$ by the product of two matrices of lower dimensions, $P_{n \times k}$ and $Q_{n\times k}$, such that 

\begin{equation}
\mathbb{R} \approx \mathbb{PQ^T}
(\#eq:R-PQ-MF)
\end{equation}

In relation to our model, the expression \@ref(eq:R-PQ-MF) will take the form:

\begin{equation}
\mathbf{R} \thicksim \mathbf{\hat{R}} + \mathbf{PQ^T} +  \varepsilon
(\#eq:UMGYDE-MF)
\end{equation}


where:
  
  - $\mathbf{R}$ is the $U_\mathrm{m} \times M_n$ rating matrix with $U_m$ users and $M_n$ movies;
  - $\mathbf{\hat{R}}$ represents the predictions from our best model: _Regularized UMGYDE Model_;
  - $\mathbf{P}$ and $\mathbf{Q}$ are $P_{m \times k}$ and $Q_{n \times k}$ matrices, respectively, where $k$ is the number of _latent features_ to be found.

If we denote the $u$-th row of $\mathbf{P}$ as $\mathbf{p}_u$ and the $v$-th row of $\mathbf{Q}$ as $\mathbf{q}_v$, then the unknown rating $\mathbf{r}_{u,v}$ given by user $u$ on movie item $v$ for our model can be estimated as $\hat{\mathbf{r}}_{u,v} + \mathbf{p}_{u}\mathbf{q}^T_{v}$, where the $\hat{\mathbf{r}}_{u,v}$ is the prediction given by our last _Regularized UMGYDE Model_.

A typical solution for $\mathbf{P}$ and $\mathbf{Q}$ is given by the following optimization problem [@chin_FPSGM_MF_SMS2015a; @chin_LRS_SGM_MF2015b]:

$$
\begin{array}{c} { min} \\
{\scriptstyle P,Q} \end{array} \sum_{(u,v)\in R}[f(\mathbf{p}_u, \mathbf{q}_v; \mathbf{r}_{u,v}) + \mu_P\parallel\mathbf{p}_u\parallel_1 + \mu_Q\parallel\mathbf{q}_v\parallel_1 + \frac{\lambda_P}2\parallel\mathbf{p}_u\parallel^2_2 + \frac{\lambda_Q}2\parallel\mathbf{q}_v\parallel^2_2]
$$

where $(u, v)$ are locations of observed entries in $\mathbf{R}, \mathbf{r}_{u,v}$ is the observed ratings, $f$ is the loss function, and $\mu_P$, $\mu_Q$, $\lambda_P$, $\lambda_Q$ are penalty parameters to avoid overfitting.[@yqiu_recosystem230505]

::: { custom-style="blockquote" } 
> _The process of solving the matrices $P$ and $Q$ is referred to as model training, and the selection of penalty parameters is called parameter tuning. In `recosystem`, we provide convenient functions for these two tasks, and additionally have functions for model exporting (outputting $P$ and $Q$ matrices) and prediction._[@yqiu_recosystem230505]

:::

\newpage

### MF: Model Building

::: {.noteblock data-latex=""}
The complete source code shown in this section is available in the [Perform the Matrix Factorization & Final Test](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2299) section of the [capstone-movielens.main.R](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2299) script on _GitHub_.
:::

We assume that the _Matrix Factorization_ method will be the last one to provide sufficient results, so we will use the entire `edx` dataset as the _Training Set_ and `final_holdout_test` as the _Test Set_ for our final model, skipping the intermediate *training/validation split operations* that were performed for the previous models.

#### MF: Getting Residuals From the UMGYDE Model Prediction Values
\

First, we will obtain residuals from the _UMGYDE Model_ prediction values using the following [line of code](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2314):
```{r main-script@l2314, eval=FALSE}
  mf.edx.residual <- mf.residual.dataframe(edx)
```

::: {.noteblock data-latex=""}
In the code snippets above, we use the [mf.residual.dataframe](#func.mf.residual.dataframe) user-defined described in section [Models Training: Support Functions]/[UMGYDE Model: Matrix Factorization] of [Appendix A](#appndx_a).
:::

```{r}
  str(mf.edx.residual)
```

#### MF: Transforming Input Data to Be Compatible With the `recosystem` Package
\

Next, we convert the residuals data and `final_holdout_test` dataset to the input data objects compatible with the [recosystem](https://cran.r-project.org/web/packages/recosystem/index.html) package using the following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2319):
```{r main-script@l2319, eval=FALSE}
  set.seed(5430)
  mf.edx.residual.reco <- with(mf.edx.residual, 
                               data_memory(user_index = userId, 
                                           item_index = movieId,
                                           rating = rsdl))

  final_holdout_test.reco <- with(final_holdout_test, 
                          data_memory(user_index = userId, 
                                      item_index = movieId, 
                                      rating = rating))
```

\newpage

```{r, echo=FALSE}
writeLines("*** `Reco` input data objects structure ***")
```
```{r}
str(mf.edx.residual.reco)
str(final_holdout_test.reco)
```

#### MF: Creating and Tuning the `Reco` Object
\

Now we can create a `reco` object of the `Reco` class and tune it using the `reco$tune` method, passing the residual data prepared in the previous step in the `train_data` argument using the following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2332):
```{r main-script@l2332, eval=FALSE}
  reco <- Reco()
  
  reco.tuned <- reco$tune(mf.edx.residual.reco, opts = list(dim = c(10, 20, 30),
                                                lrate    = c(0.1, 0.2),
                                                nthread  = 4,
                                                niter    = 10,
                                                verbose  = TRUE))
```

\newpage

```{r, echo=FALSE}
writeLines("*** `Reco` object structure ***")
```
```{r}
str(reco)
```

\newpage

```{r, echo=FALSE}
writeLines("*** Tuned `Reco` object structure ***")
```
```{r}
str(reco.tuned)
```

\newpage

#### MF: Final Training
\

Finally, we train the model for the last time using the `reco$train` method, passing the same residual data we used for the tuning, in the `train_data` argument, using the following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2342):
```{r main-script@l2342, eval=FALSE}
  reco$train(mf.edx.residual.reco, opts = c(reco.tuned$min,
                                       niter = 20, 
                                       nthread = 4)) 
```

#### MF: Final Holdout Test
\

From now on, we will work with the `final_holdout_test` dataset for the final testing of our model, including obtaining final predictions and computing the final *RMSE* score.

Now, let's compute the final predictions, combining the predicted residuals from the `reco` objects and predicted values we lastly get from the _UMGYDE Model_ as described in section [UMGYDE Model: Final Holdout Test (Preliminary Assessment)], using the following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2346):
```{r main-script@l2346, eval=FALSE}
  mf.reco.residual <- reco$predict(final_holdout_test.reco, out_memory())

  mf.predicted_ratings <- 
    clamp(final.UMGYDE.predicted$predicted + mf.reco.residual)
```

::: {.noteblock data-latex=""}
In the code snippet above, we use the [clamp](#func.clamp) user-defined function described in section [Utility Functions] of [Appendix A](#appndx_a).
:::

```{r}
str(mf.reco.residual)
str(mf.predicted_ratings)
```

And ultimately, we are ready to compute the  final *RMSE* score using the following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2374):
```{r main-script@l2374, eval=FALSE}
final_holdout_test.RMSE <- rmse2(final_holdout_test$rating,
                                     mf.predicted_ratings)
```

::: {.noteblock data-latex=""}
In the code snippet above, we use the [rmse2](#func.rmse2) user-defined function described in section [(Root) Mean Squared Error Calculation] of [Appendix A](#appndx_a).
:::

\newpage

Finally, we add the *RMSE* value obtained above to our *Result Table* and print the table using the following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2380):
```{r main-script@l2380, eval=FALSE}
final.MF.RMSEs.ResultTibble <- final.RMSEs.ResultTibble.UMGYDE.rglr.tuned |> 
  RMSEs.AddRow("MF (Final Test)", 
               final_holdout_test.RMSE,
               comment = "Matrix Factorization of the Best Model Residuals, Final Holdout Test")
```
```{r}
RMSE_kable(final.MF.RMSEs.ResultTibble)
```

::: {.noteblock data-latex=""}
In the code snippet above, we use the [RMSEs.AddRow](#func.RMSEs.AddRow) and [RMSE_kable](#func.RMSE_kable) functions described in section [Result RMSEs Tibble Functions] of [Appendix A](#appndx_a).
:::

Eventually, we have reached our ultimate goal, as the *RMSE* we obtained has achieved the required Project Objective.

\newpage

