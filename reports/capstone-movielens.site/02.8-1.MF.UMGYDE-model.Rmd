## UMGYDE Model: Matrix Factorization (MF)
\

::: {.noteblock data-latex=""}
The complete source code shown in this section is available in the [Matrix Factorization (MF)](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2230) section of the [capstone-movielens.main.R](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2230) script on _GitHub_.
:::

For our next solution, we will use the [`recosystem` package](https://cran.r-project.org/web/packages/recosystem/index.html) to perform the _Parallel Matrix Factorization_.

### MF: Matematical Description
\

As outlined in [this article](https://cran.r-project.org/web/packages/recosystem/vignettes/introduction.html)[@yqiu_recosystem230505], the idea of the _Matrix Factorization_ method is to approximate the whole rating matrix $R_{m \times n}$ by the product of two matrices of lower dimensions, $P_{n \times k}$ and $Q_{n\times k}$, such that 

\begin{equation}
\mathbb{R} \approx \mathbb{PQ^T}
(\#eq:R-PQ-MF)
\end{equation}

In relation to our model, the expression \@ref(eq:R-PQ-MF) will take the form:

\begin{equation}
\mathbf{R} \thicksim \mathbf{\hat{R}} + \mathbf{PQ^T} +  \varepsilon
(\#eq:UMGYDE-MF)
\end{equation}


where:
  
  - $\mathbf{R}$ is the $U_\mathrm{m} \times M_n$ rating matrix with $U_m$ users and $M_n$ movies;
  - $\mathbf{\hat{R}}$ represents the predictions from our best model: _Regularized UMGYDE Model_;
  - $\mathbf{P}$ and $\mathbf{Q}$ are $P_{m \times k}$ and $Q_{n \times k}$ matrices, respectively, where $k$ is the number of _latent features_ to be found.

If we denote the $u$-th row of $\mathbf{P}$ as $\mathbf{p}_u$ and the $v$-th row of $\mathbf{Q}$ as $\mathbf{q}_v$, then the unknown rating $\mathbf{r}_{u,v}$ given by user $u$ on movie item $v$ for our model can be estimated as $\hat{\mathbf{r}}_{u,v} + \mathbf{p}_{u}\mathbf{q}^T_{v}$, where the $\hat{\mathbf{r}}_{u,v}$ is the prediction given by our last _Regularized UMGYDE Model_.

A typical solution for $\mathbf{P}$ and $\mathbf{Q}$ is given by the following optimization problem [@chin_FPSGM_MF_SMS2015a; @chin_LRS_SGM_MF2015b]:

$$
\begin{array}{c} { min} \\
{\scriptstyle P,Q} \end{array} \sum_{(u,v)\in R}[f(\mathbf{p}_u, \mathbf{q}_v; \mathbf{r}_{u,v}) + \mu_P\parallel\mathbf{p}_u\parallel_1 + \mu_Q\parallel\mathbf{q}_v\parallel_1 + \frac{\lambda_P}2\parallel\mathbf{p}_u\parallel^2_2 + \frac{\lambda_Q}2\parallel\mathbf{q}_v\parallel^2_2]
$$

where $(u, v)$ are locations of observed entries in $\mathbf{R}, \mathbf{r}_{u,v}$ is the observed ratings, $f$ is the loss function, and $\mu_P$, $\mu_Q$, $\lambda_P$, $\lambda_Q$ are penalty parameters to avoid overfitting.[@yqiu_recosystem230505]

::: { custom-style="blockquote" } 
> _The process of solving the matrices $P$ and $Q$ is referred to as model training, and the selection of penalty parameters is called parameter tuning. In `recosystem`, we provide convenient functions for these two tasks, and additionally have functions for model exporting (outputting $P$ and $Q$ matrices) and prediction._[@yqiu_recosystem230505]

:::

\newpage

### MF: Model Building
\

::: {.noteblock data-latex=""}
The complete source code shown in this section is available in the [Perform the Matrix Factorization & Final Test](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2253) section of the [capstone-movielens.main.R](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2253) script on _GitHub_.
:::

We assume that the _Matrix Factorization_ method will be the last one to provide sufficient results, so we will use the entire `edx` dataset as the _Training Set_ and `final_holdout_test` as the _Test Set_ for our *final model training and testing*, skipping the intermediate *training/validation split operations* that applied for the previous models.

#### MF: Getting Residuals From the UMGYDE Model Prediction Values
\

First, we will obtain residuals from the _UMGYDE Model_ prediction values using the following [line of code](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2268):
```{r main-script@l2268, eval=FALSE}
  mf.edx.residual <- mf.residual.dataframe(edx)
```

::: {.noteblock data-latex=""}
In the code snippets above, we use the [mf.residual.dataframe](#func.mf.residual.dataframe) user-defined helper function described in section [UMGYDE Model: Matrix Factorization] of [Appendix A](#appndx_a).
:::

```{r}
  str(mf.edx.residual)
```

#### MF: Transforming Input Data to Be Compatible With the `recosystem` Package
\

Next, we convert the residuals data and `final_holdout_test` dataset to the input data objects compatible with the [recosystem](https://cran.r-project.org/web/packages/recosystem/index.html) package using the following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2273):
```{r main-script@l2273, eval=FALSE}
  set.seed(5430)
  mf.edx.residual.reco <- with(mf.edx.residual, 
                               data_memory(user_index = userId, 
                                           item_index = movieId,
                                           rating = rsdl))

  final_holdout_test.reco <- with(final_holdout_test, 
                          data_memory(user_index = userId, 
                                      item_index = movieId, 
                                      rating = rating))
```

\newpage

```{r, echo=FALSE}
writeLines("*** `Reco` input data objects structure ***")
```
```{r}
str(mf.edx.residual.reco)
str(final_holdout_test.reco)
```

#### MF: Creating and Tuning the `Reco` Object
\

Now we can create a `reco` object of the `Reco` class and tune it using the `reco$tune` method, passing the residual data prepared in the previous step in the `train_data` argument using the following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2284):
```{r main-script@l2284, eval=FALSE}
  reco <- Reco()
  
  reco.tuned <- reco$tune(mf.edx.residual.reco, opts = list(dim = c(10, 20, 30),
                                                lrate    = c(0.1, 0.2),
                                                nthread  = 4,
                                                niter    = 10,
                                                verbose  = TRUE))
```

\newpage

```{r, echo=FALSE}
writeLines("*** `Reco` object structure ***")
```
```{r}
str(reco)
```

\newpage

```{r, echo=FALSE}
writeLines("*** Tuned `Reco` object structure ***")
```
```{r}
str(reco.tuned)
```

\newpage

#### MF: Final Training
\

Finally, we train the model for the last time using the `reco$train` method, passing the same residual data we used for the tuning, in the `train_data` argument, using the following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2296):
```{r main-script@l2296, eval=FALSE}
  reco$train(mf.edx.residual.reco, opts = c(reco.tuned$min,
                                       niter = 20, 
                                       nthread = 4)) 
```

### MF: Final Holdout Test
\

From now on, we will work with the `final_holdout_test` dataset for the final testing of our model, including obtaining final predictions and computing the final *RMSE* score.

First, let's compute predictions for the best model we built above, *Regularized UMGYDE Model* (as described in section [UMGYDE Model Regularization: *Retraining on the `edx` with the best* $\lambda$]), using the following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2300):
```{r main-script@l2300, eval=FALSE}
# Compute predictions from Regularized UMGYDE Model
final.UMGYDE.predicted <- final_holdout_test |>
  UMGY_SmoothedDay_effect.predict(rglr.UMGYD_effect)
```
```{r}
str(final.UMGYDE.predicted)
```

::: {.noteblock data-latex=""}
In the code snippet above we use the [UMGY_SmoothedDay_effect.predict](#func.UMGY_SmoothedDay_effect.predict) function described in section [UMGYDE Model: Utility Functions] of [Appendix A](#appndx_a).
:::

Next, we get predicted residuals from the `reco` object, using the following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2323):
```{r main-script@l2323, eval=FALSE}
# Compute residuals from trained Reco object
mf.reco.residual <- reco$predict(final_holdout_test.reco, out_memory())
```
```{r}
str(mf.reco.residual)
```

\newpage

Finally, we compute the ultimate predictions combining the predicted rating values we obtained above from the *Regularized UMGYDE Model* and the residuals obtained from the `reco` object, using the following  [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2328):
```{r main-script@l2328, eval=FALSE}
# Compute Final Holdout Predictions
mf.predicted_ratings <- 
  clamp(final.UMGYDE.predicted$predicted + mf.reco.residual)
```
```{r}
str(mf.predicted_ratings)
```

::: {.noteblock data-latex=""}
In the code snippet above, we use the [clamp](#func.clamp) user-defined helper function described in section [Utility Functions] of [Appendix A](#appndx_a).
:::

And ultimately, we are ready to compute the  final *RMSE* score using the following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2353):
```{r main-script@l2353, eval=FALSE}
final_holdout_test.RMSE <- rmse2(final_holdout_test$rating,
                                     mf.predicted_ratings)
```
```{r}
final_holdout_test.RMSE
```

::: {.noteblock data-latex=""}
In the code snippet above, we use the [rmse2](#func.rmse2) user-defined helper function described in section [(Root) Mean Squared Error Calculation] of [Appendix A](#appndx_a).
:::

\newpage

Finally, we add the *RMSE* value obtained above to our *Result Table* and print the table using the following [code snippet](https://github.com/AzKurban-edX-DS/Capstone-MovieLens/blob/main/r/src/capstone-movielens.main.R#L2359):
```{r main-script@l2359, eval=FALSE}
final.MF.RMSEs.ResultTibble <- RMSEs.ResultTibble.UMGYDE.rglr.tuned |> 
  RMSEs.AddRow("MF (Final Test)", 
               final_holdout_test.RMSE,
               comment = "Matrix Factorization of the Best Model Residuals, Final Holdout Test")
```
```{r}
RMSE_kable(final.MF.RMSEs.ResultTibble)
```

::: {.noteblock data-latex=""}
In the code snippet above, we use the [RMSEs.AddRow](#func.RMSEs.AddRow) and [RMSE_kable](#func.RMSE_kable) functions described in section [Result RMSEs Tibble Functions] of [Appendix A](#appndx_a).
:::

Eventually, we have reached our ultimate goal, as the *RMSE* we obtained has achieved the required Project Objective.

\newpage

